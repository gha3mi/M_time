<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="github-markdown.css">
<style>
@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

.markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.markdown-body .anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  line-height: 1.5;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #032f62;
}

.markdown-body .pl-smw,
.markdown-body .pl-v {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  background-color: #b31d28;
  color: #fafbfc;
}

.markdown-body .pl-c2 {
  background-color: #d73a49;
  color: #fafbfc;
}

.markdown-body .pl-c2:before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  color: #22863a;
  font-weight: 700;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #005cc5;
  font-weight: 700;
}

.markdown-body .pl-mi {
  color: #24292e;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #24292e;
  font-weight: 700;
}

.markdown-body .pl-md {
  background-color: #ffeef0;
  color: #b31d28;
}

.markdown-body .pl-mi1 {
  background-color: #f0fff4;
  color: #22863a;
}

.markdown-body .pl-mc {
  background-color: #ffebda;
  color: #e36209;
}

.markdown-body .pl-mi2 {
  background-color: #005cc5;
  color: #f6f8fa;
}

.markdown-body .pl-mdr {
  color: #6f42c1;
  font-weight: 700;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  color: #032f62;
  text-decoration: underline;
}

.markdown-body details {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: .67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

.markdown-body hr:before {
  content: "";
  display: table;
}

.markdown-body hr:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body h1 {
  font-size: 32px;
}

.markdown-body h1,
.markdown-body h2 {
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
}

.markdown-body h3 {
  font-size: 20px;
}

.markdown-body h3,
.markdown-body h4 {
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
}

.markdown-body h5 {
  font-size: 14px;
}

.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
}

.markdown-body p {
  margin-bottom: 10px;
  margin-top: 0;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ol,
.markdown-body ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre {
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body input::-webkit-inner-spin-button,
.markdown-body input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.markdown-body .border {
  border: 1px solid #e1e4e8!important;
}

.markdown-body .border-0 {
  border: 0!important;
}

.markdown-body .border-bottom {
  border-bottom: 1px solid #e1e4e8!important;
}

.markdown-body .rounded-1 {
  border-radius: 3px!important;
}

.markdown-body .bg-white {
  background-color: #fff!important;
}

.markdown-body .bg-gray-light {
  background-color: #fafbfc!important;
}

.markdown-body .text-gray-light {
  color: #6a737d!important;
}

.markdown-body .mb-0 {
  margin-bottom: 0!important;
}

.markdown-body .my-2 {
  margin-bottom: 8px!important;
  margin-top: 8px!important;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .py-0 {
  padding-bottom: 0!important;
  padding-top: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .py-2 {
  padding-bottom: 8px!important;
  padding-top: 8px!important;
}

.markdown-body .pl-3,
.markdown-body .px-3 {
  padding-left: 16px!important;
}

.markdown-body .px-3 {
  padding-right: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .f6 {
  font-size: 12px!important;
}

.markdown-body .lh-condensed {
  line-height: 1.25!important;
}

.markdown-body .text-bold {
  font-weight: 600!important;
}

.markdown-body:before {
  content: "";
  display: table;
}

.markdown-body:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body>:first-child {
  margin-top: 0!important;
}

.markdown-body>:last-child {
  margin-bottom: 0!important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
}

.markdown-body hr {
  background-color: #e1e4e8;
  border: 0;
  height: .25em;
  margin: 24px 0;
  padding: 0;
}

.markdown-body blockquote {
  border-left: .25em solid #dfe2e5;
  color: #6a737d;
  padding: 0 1em;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
  line-height: 1.25;
  margin-bottom: 16px;
  margin-top: 24px;
}

.markdown-body h1 {
  font-size: 2em;
}

.markdown-body h1,
.markdown-body h2 {
  border-bottom: 1px solid #eaecef;
  padding-bottom: .3em;
}

.markdown-body h2 {
  font-size: 1.5em;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: .875em;
}

.markdown-body h6 {
  color: #6a737d;
  font-size: .85em;
}

.markdown-body ol,
.markdown-body ul {
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

.markdown-body dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

.markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table td,
.markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  background-color: #fff;
  box-sizing: content-box;
  max-width: 100%;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: .2em .4em;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

.markdown-body pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

.markdown-body .commit-tease-sha {
  color: #444d56;
  display: inline-block;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 90%;
}

.markdown-body .blob-wrapper {
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  overflow-x: auto;
  overflow-y: hidden;
}

.markdown-body .blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.markdown-body .blob-num {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  color: rgba(27,31,35,.3);
  cursor: pointer;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  line-height: 20px;
  min-width: 50px;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
  user-select: none;
  vertical-align: top;
  white-space: nowrap;
  width: 1%;
}

.markdown-body .blob-num:hover {
  color: rgba(27,31,35,.6);
}

.markdown-body .blob-num:before {
  content: attr(data-line-number);
}

.markdown-body .blob-code {
  line-height: 20px;
  padding-left: 10px;
  padding-right: 10px;
  position: relative;
  vertical-align: top;
}

.markdown-body .blob-code-inner {
  color: #24292e;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  overflow: visible;
  white-space: pre;
  word-wrap: normal;
}

.markdown-body .pl-token.active,
.markdown-body .pl-token:hover {
  background: #ffea7f;
  cursor: pointer;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body :checked+.radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.markdown-body .tab-size[data-tab-size="1"] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.markdown-body .tab-size[data-tab-size="2"] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.markdown-body .tab-size[data-tab-size="3"] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.markdown-body .tab-size[data-tab-size="4"] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.markdown-body .tab-size[data-tab-size="5"] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.markdown-body .tab-size[data-tab-size="6"] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.markdown-body .tab-size[data-tab-size="7"] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.markdown-body .tab-size[data-tab-size="8"] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.markdown-body .tab-size[data-tab-size="9"] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.markdown-body .tab-size[data-tab-size="10"] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.markdown-body .tab-size[data-tab-size="11"] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.markdown-body .tab-size[data-tab-size="12"] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .pl-3 {
  padding-left: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .pl-7 {
  padding-left: 48px!important;
}

.markdown-body .pl-8 {
  padding-left: 64px!important;
}

.markdown-body .pl-9 {
  padding-left: 80px!important;
}

.markdown-body .pl-10 {
  padding-left: 96px!important;
}

.markdown-body .pl-11 {
  padding-left: 112px!important;
}

.markdown-body .pl-12 {
  padding-left: 128px!important;
}
</style>
<style>
 .markdown-body {
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 0 auto;
  padding: 45px;
 }

 @media (max-width: 767px) {
  .markdown-body {
   padding: 15px;
  }
 }
</style>
</head>
<body>
<article class="markdown-body">
<?
<div><P style="page-break-before: always">
      <!-- =========================================================================================================================== -->
      <dl>
        <dt>NAME</dt>
        <dd>M_time - [M_time] Fortran module for manipulating and presenting time and date values</dd>
        <dt>DESCRIPTION</dt>
        <dd>
          <p>The M_time(3f) Fortran module and associated utility programs provide date and time-related procedures. Both a procedural and OOP (Object
          Oriented Programming) interface are provided. Each routine is accompanied by a man(1) page which includes a sample program for that procedure.
          This manual, the source and example programs are included in the download.</p>
          <p>The M_time(3f) module</p>
          <ul>
            <li>provides for formatting dates.</li>
            <li>facilitates simple computations using time and date values in the recent era.</li>
            <li>allow for macro-level timing of code.</li>
          </ul>
          <p>The M_TIME(3f) module complements the DATE_AND_TIME(3f) procedure, which is the standard intrinsic subroutine that returns the current date and
          time in the Gregorian calendar. That is, the primary way this module represents dates is as an integer array with the same meaning for elements as
          defined by the DATE_AND_TIME(3f) routine. In addition it can calculate or read many other date representations such as ...</p>
          <ul>
            <li>Julian Dates</li>
            <li>Unix Epoch Dates</li>
            <li>High-level date formatting</li>
            <li>Ordinal days of the year</li>
            <li>days of the week</li>
            <li>ISO-8601 week numbers</li>
            <li>month and weekday names</li>
          </ul>
          <p>Julian and Unix Epoch Dates are particularly useful for manipulating dates in simple numeric expressions.</p>
          <p>The extensive formatting options include showing SYSTEM_CLOCK(3f) and CPU_USAGE(3f) information along with Gregorian date information, allowing
          for the easy incorporation of timing information into program messages. In addition to conventional Civilian Calendar dates, the module supports
          the ISO-8601 standard methods of displaying dates.</p>
        </dd>
        <dt>SYNOPSIS</dt>
        <dd>
          <table border="1">
            <tr>
              <th colspan="3">UNIX EPOCH</th>
            </tr>
            <tr>
              <td><a href="date_to_unix.3.html">date_to_unix(dat,UNIXTIME,IERR)</a></td>
              <td>%epoch()</td>
              <td>Convert date array to Unix Time</td>
            </tr>
            <tr>
              <td><a href="unix_to_date.3.html">unix_to_date(unixtime,DAT,IERR)</a></td>
              <td></td>
              <td>Convert Unix Time to date array</td>
            </tr>
            <tr>
              <td><a href="d2u.3.html">d2u(dat) result (UNIXTIME)</a></td>
              <td></td>
              <td>Convert date array to Unix Time</td>
            </tr>
            <tr>
              <td><a href="u2d.3.html">u2d(unixtime) result (DAT)</a></td>
              <td></td>
              <td>Convert Unix Time to date array</td>
            </tr>
            <tr>
              <th colspan="3">JULIAN</th>
            </tr>
            <tr>
              <td><a href="julian_to_date.3.html">julian_to_date(julian,DAT,IERR)</a></td>
              <td></td>
              <td>Convert Julian Date to date array</td>
            </tr>
            <tr>
              <td><a href="date_to_julian.3.html">date_to_julian(dat,JULIAN,IERR)</a></td>
              <td>%julian()</td>
              <td>Converts date array to Julian Date</td>
            </tr>
            <tr>
              <td><a href="d2j.3.html">d2j(dat) result (JULIAN)</a></td>
              <td></td>
              <td>Convert date array to Julian Date</td>
            </tr>
            <tr>
              <td><a href="j2d.3.html">j2d(julian) result (DAT)</a></td>
              <td></td>
              <td>Convert Julian Date to date array</td>
            </tr>
            <tr>
              <th colspan="3">DAY OF WEEK</th>
            </tr>
            <tr>
              <td><a href="dow.3.html">dow(dat,[WEEKDAY],[DAY],IERR)</a></td>
              <td>%weekday()</td>
              <td>Convert date array to day of the week as number(Mon=1) and name</td>
            </tr>
            <tr>
              <th colspan="3">WEEK OF YEAR</th>
            </tr>
            <tr>
              <td><a href="d2w.3.html">d2w(dat,ISO_YEAR,ISO_WEEK,ISO_WEEKDAY,ISO_NAME)</a></td>
              <td></td>
              <td>calculate iso-8601 Week-numbering year date yyyy-Www-d</td>
            </tr>
            <tr>
              <td><a href="w2d.3.html">w2d(iso_year,iso_week,iso_weekday,DAT)</a></td>
              <td></td>
              <td>calculate date given iso-8601 Week date yyyy-Www-d</td>
            </tr>
            <tr>
              <th colspan="3">ORDINAL DAY</th>
            </tr>
            <tr>
              <td><a href="d2o.3.html">d2o(dat) result(ORDINAL)</a></td>
              <td>%ordinal()</td>
              <td>given date array return ordinal day of year, Jan 1st=1</td>
            </tr>
            <tr>
              <td><a href="o2d.3.html">o2d(ordinal,[year]) result(DAT)</a></td>
              <td></td>
              <td>given ordinal day of year return date array, Jan 1st=1</td>
            </tr>
            <tr>
              <td><a href="ordinal_to_date.3.html">ordinal_to_date(ordinal,year,DAT)</a></td>
              <td></td>
              <td>given ordinal day of year return date array, Jan 1st=1</td>
            </tr>
            <tr>
              <td><a href="ordinal_seconds.3.html">ordinal_seconds()</a></td>
              <td></td>
              <td>return seconds since beginning of year</td>
            </tr>
            <tr>
              <th colspan="3">PRINTING DATES</th>
            </tr>
            <tr>
              <td><a href="fmtdate.3.html">fmtdate(dat,format) result (TIMESTR)</a></td>
              <td>%format([STRING])</td>
              <td>Convert date array to string using format</td>
            </tr>
            <tr>
              <td><a href="fmtdate_usage.3.html">fmtdate_usage(indent)</a></td>
              <td></td>
              <td>display macros recognized by fmtdate(3f)</td>
            </tr>
            <tr>
              <td><a href="now.3.html">now(format) result (NOW)</a></td>
              <td></td>
              <td>return string representing current time given format</td>
            </tr>
            <tr>
              <td><a href="box_month.3.html">box_month(dat,CALEN)</a></td>
              <td></td>
              <td>print specified month into character array</td>
            </tr>
            <tr>
              <th colspan="3">MONTH NAME</th>
            </tr>
            <tr>
              <td><a href="mo2v.3.html">mo2v(month_name) result (MONTH_NUMBER)</a></td>
              <td></td>
              <td>given month name return month number</td>
            </tr>
            <tr>
              <td><a href="v2mo.3.html">v2mo(month_number) result (MONTH_NAME)</a></td>
              <td></td>
              <td>given month number return month name</td>
            </tr>
            <tr>
              <td><a href="mo2d.3.html">mo2d(month_name) result (DAT)</a></td>
              <td></td>
              <td>return date array for first day of given month name in specified year</td>
            </tr>
            <tr>
              <th colspan="3">ASTROLOGICAL</th>
            </tr>
            <tr>
              <td><a href="easter.3.html">easter(year,dat)</a></td>
              <td></td>
              <td>calculate month and day Easter falls on for given year</td>
            </tr><!--
<tr><td><a href="ephemeris.3.html"> ephemeris(dat,planet,DEC_D,DEC,M,DEC_C,ASCENT_H,ASCENT_M) </a></td><td>&nbsp; </td><td> ephemeris position of planets for adjusting an equatorial telescope </td></tr>
-->
            <tr>
              <td><a href="moon_fullness.3.html">moon_fullness(DAT) result(FULLNESS)</a></td>
              <td></td>
              <td>percentage of moon phase from new to full</td>
            </tr>
            <tr>
              <td><a href="phase_of_moon.3.html">phase_of_moon(DAT) result(PHASE)</a></td>
              <td></td>
              <td>return name for phase of moon for given date</td>
            </tr>
            <tr>
              <th colspan="3">DURATION</th>
            </tr>
            <tr>
              <td><a href="sec2days.3.html">sec2days(seconds) result(dhms)</a></td>
              <td></td>
              <td>converts seconds to string D-HH:MM:SS</td>
            </tr>
            <tr>
              <td><a href="days2sec.3.html">days2sec(string) result(seconds)</a></td>
              <td></td>
              <td>converts string D-HH:MM:SS to seconds</td>
            </tr>
            <tr>
              <th colspan="3">READING DATES</th>
            </tr>
            <tr>
              <td><a href="guessdate.3.html">guessdate(anot,dat)</a></td>
              <td></td>
              <td>Converts a date string to a date array, in various formats</td>
            </tr>
          </table>
        </dd>
        <dt>FORMATTING OPTIONS IN <code>FMTDATE</code></dt>
        <dd>
          <p>You can easily use Julian Ephemeris Dates and Unix Epoch Times to add and subtract times from dates or to calculate the interval between dates.
          But JEDs and UETs and even the Gregorian Calendar arrays in the DAT arrays are not the way we typically describe a date on the Civilian Calendar.
          So the fmtdate(3f) routine lets us print a DAT array in a variety of familiar styles.</p>
          <p>The fmtdate(3f) and now(3f) procedures let you display a Gregorian date using either keywords for standard formats or using macros in a
          user-specified formatting string. A formatting string may contain the following macros:</p>
<pre>
Description                                        Example
 Base time array:
  (1) %Y -- year, yyyy                                2016
  (2) %M -- month of year, 01 to 12                   07
  (3) %D -- day of month, 01 to 31                    27
      %d -- day of month, with suffix (1st, 2nd,...)  27th
  (4) %Z -- minutes from UTC                          -0240
      %z -- -+hh:mm from UTC                          -04:00
      %T -- -+hhmm  from UTC                          -0400
  (5) %h -- hours, 00 to 23                           21
      %H -- hour (1 to 12, or twelve-hour clock)      09
      %N -- midnight&lt; AM &lt;=noon; noon&lt;= PM &lt;midnight  PM
  (6) %m -- minutes, 00 to 59                         24
  (7) %s -- sec, 00 to 59                             22
  (8) %x -- milliseconds 000 to 999                   512
 Conversions:
      %E -- Unix Epoch time                           1469669062.5129952
      %e -- integer value of Unix Epoch time          1469669063
      %J -- Julian  date                              2457597.559
      %j -- integer value of Julian Date(Julian Day)  2457597
      %O -- Ordinal day (day of year)                 209
      %o -- whole days since Unix Epoch date          17009
      %U -- day of week, 1..7 Sunday=1                4
      %u -- day of week, 1..7 Monday=1                3
      %i -- ISO week of year 1..53                    30
      %I -- iso-8601 week-numbering date(yyyy-Www-d)  2016-W30-3
  Names:
      %l -- abbreviated month name                    Jul
      %L -- full month name                           July
      %w -- first three characters of weekday         Wed
      %W -- weekday name                              Wednesday
      %p -- phase of moon                             New
      %P -- percent of way from new to full moon      -1%
  Literals:
      %% -- a literal %                               %
      %t -- tab character
      %b -- blank character
      %B -- exclamation(bang) character
      %n -- new line (system dependent)
      %q -- single quote (apostrophe)
      %Q -- double quote
  Program timing:
      %c -- CPU_TIME(3f) output                       .78125000000000000E-001
      %C -- number of times this routine is used      1
      %S -- seconds since last use of this format     .0000000000000000
      %k -- time in seconds from SYSTEM_CLOCK(3f)     588272.750
      %K -- time in clicks from SYSTEM_CLOCK(3f)      588272750
If no percent (%) is found in the format one of several
alternate substitutions occurs.
If the format is composed entirely of one of the following
keywords the following substitution occurs:
  "iso-8601",
  "iso"        ==&gt; %Y-%M-%DT%h:%m:%s%z  ! Example: 2017-08-26T18:56:33,510912700-04:00
  "iso-8601W",
  "isoweek"    ==&gt; %I
  "sql"        ==&gt; "%Y-%M-%D %h:%m:%s.%x"
  "sqlday"     ==&gt; "%Y-%M-%D"
  "sqltime"    ==&gt; "%h:%m:%s.%x"
  "rfc-2822"   ==&gt; %w, %D %l %Y %h:%m:%s %T  !  Example: Mon, 14 Aug 2006 02:34:56 -0600
  "rfc-3339"   ==&gt; %Y-%M-%DT%h:%m:%s%z  !  Example: 2006-08-14 02:34:56-06:00
  "date"       ==&gt; %w %l %D %h:%m:%s UTC%z %Y
  "short"      ==&gt; %w, %l %d, %Y %H:%m:%s %N UTC%z
  "long"," "   ==&gt; %W, %L %d, %Y %H:%m:%s %N UTC%z
  "suffix"     ==&gt; %Y%D%M%h%m%s
  "formal"     ==&gt; The %d of %L %Y
  "lord"       ==&gt; the %d day of %L in the year of our Lord %Y
  "easter"     ==&gt; FOR THE YEAR OF THE CURRENT DATE:
                      Easter day: the %d day of %L in the year of our Lord %Y
  "all"        ==&gt; A SAMPLE OF DATE FORMATS
otherwise the following words are replaced with the most
common macros:
   STRING   MACRO  EXAMPLE
   year     %Y     2016
   month    %M     07
   day      %D     27
   hour     %h     21
   minute   %m     24
   second   %s     22
   epoch    %e     1469669063
   julian   %j     2457597
   ordinal  %O     209
   weekday  %u     3
if none of these keywords are found then every letter that
is a macro is assumed to have an implied percent in front
of it. For example:
   YMDhms ==&gt; %Y%M%D%h%m%s ==&gt; 20160727212422
</pre>
        </dd>
        <dt>OOPS INTERFACE</dt>
        <dd>
          <p>If you prefer an Object-oriented interface the M_time_oop module (included with the M_time module source) provides an OOP interface to the
          M_time module; as described in the subroutine OBJECT_ORIENTED() in the example section.</p>
        </dd>
        <dt>EXAMPLES</dt>
        <dd>
          <p>The following example program demonstrates the extensive options available for formatting a date as well as how to use the module to calculate
          dates such as "Yesterday" and "Tomorrow", as well as how to use the Object Oriented interface to the conventional procedures found in the
          M_time(3fm) module.</p>
          <pre class="fortran">
program demo_M_time
   call procedural()
   call object_oriented()
!===============================================================================
contains
!===============================================================================
subroutine procedural()
use M_time, only:  j2d, d2j, u2d, d2u, fmtdate, realtime
integer                      :: dat(8)
real(kind=realtime)          :: julian, unixtime
character(len=*),parameter   :: iso_fmt='%Y-%M-%DT%h:%m:%s.%x%z'
character(len=:),allocatable :: friendly
   friendly='%W, %L %d, %Y %H:%m:%s %N' ! a nice friendly format
   call date_and_time(values=dat)  ! current time is placed in array
   write(*,*)'Today'
   write(*,*)'ISO       ',fmtdate(dat,iso_fmt)
   write(*,*)'Friendly  ',fmtdate(dat,friendly)
   write(*,*)'ISO week  ',fmtdate(dat,'%I')
   julian=d2j(dat)
   unixtime=d2u(dat)
   write(*,*)'Yesterday' ! subtract a day from scalar time and print
   write(*,*)'          ',fmtdate(u2d(unixtime-86400),iso_fmt)
   write(*,*)'          ',fmtdate(j2d(julian-1.0),friendly)
   write(*,*)'          ',fmtdate(j2d(julian-1.0),'%I')
   write(*,*)'Tomorrow'  ! add a day to scalar time and print
   write(*,*)'          ',fmtdate(u2d(unixtime+86400),iso_fmt)
   write(*,*)'          ',fmtdate(j2d(julian+1.0),friendly)
   write(*,*)'          ',fmtdate(j2d(julian+1.0),'%I')
   write(*,*)'Next Week'  ! add a week to scalar time and print
   write(*,*)'          ',fmtdate(u2d(unixtime+7*86400),iso_fmt)
   write(*,*)'          ',fmtdate(j2d(julian+7.0),friendly)
   write(*,*)'          ',fmtdate(j2d(julian+7.0),'%I')
end subroutine procedural
!=========================================================================================
subroutine object_oriented()
!
! This is an example using the object-oriented class/type model
! This is essentially the same functionality as the procedures
! described above, but if you prefer this type of syntax this may
! seem more intuitive ...
!
use M_time_oop,only : date_time
!!use M_time_oop,only : operator(+),operator(-),operator(&gt;),operator(&lt;)
!!use M_time_oop,only : operator(&lt;=),operator(&gt;=),operator(==),operator(/=)
implicit none
integer         :: dat(8)
TYPE(date_time) :: event
TYPE(date_time) :: otherdate
TYPE(date_time) :: answer
character(len=*),parameter   :: iso_fmt='%Y-%M-%DT%h:%m:%s.%x%z'
   ! DIFFERENT INITIALIZATION STYLES (Still debating on how best to do this)
   write(*,*)
   write(*,*)'Various initialization styes'
   ! DEFINE TYPE(DATE_TIME) WITH CONSTRUCTOR
   otherdate=date_time()
   print *,'DEFAULT CONSTRUCTOR %FORMAT()               ',otherdate%format()
   print *,'DEFAULT CONSTRUCTOR %FORMAT("")             ',otherdate%format("")
   print *,'DEFAULT CONSTRUCTOR %FORMAT(user-specified) ',otherdate%format(iso_fmt)
   print *,'DEFAULT CONSTRUCTOR %FORMAT("USA")          ',otherdate%format("USA")
   otherdate=date_time(1492,10,12,0,0,0,0,0)
   print *,'DEFAULT CONSTRUCTOR SETTING VALUES          ',otherdate%format()
   otherdate=date_time(2016,6,11)
   print *,'DEFAULT CONSTRUCTOR WITH PARTIAL VALUES     ',otherdate%format()
   otherdate=date_time(year=2016,month=6,day=11,tz=-240,hour=21,minute=09,second=11,millisecond=500)
   print *,'DEFAULT CONSTRUCTOR WITH VALUES BY NAME     ',otherdate%format()
   otherdate=date_time([1776,7,4,0,0,0,0,0])
   print *,'CONSTRUCTOR WITH A DAT ARRAY                ',otherdate%format()
   otherdate=date_time([1776,7,4])
   print *,'CONSTRUCTOR WITH A PARTIAL DAT ARRAY        ',otherdate%format()
   ! the init() method supports several methods
   call otherdate%init()                           ! initialize to current time using INIT
   call otherdate%init(type="now")                 ! initialize to current time using INIT
   call otherdate%init(type="epoch")               ! initialize to beginning of Unix Epoch Time
   ! Note
   ! currently, DATE_TIME DATE array is set to Unix Epoch start USING LOCAL TIMEZONE
   ! whereas default constructor is using default of Unix Epoch start using Z time (GMT or UTC time)
   ! initialize with a DAT array using INIT, compatible with DATE_AND_TIME VALUES(8)
   call otherdate%init(dat=[1970,1,1,0,0,0,0,0])
   call otherdate%init(2016,6,11,-300,23,1,0,0)    ! using INIT with ordered values
   ! using INIT with names
   call otherdate%init(year=2016,month=6,day=11,tz=-300,hour=23,minute=1,second=0,millisecond=0)
   !============================================================================
   ! take current date and exercise the OOP interface
   call event%init()                                           ! initialize to current time using INIT
   write(*,*)
   write(*,*)'Print members of type(DATE_TIME)'
   write(*,404)'EVENT=',event                                  ! show derived type
   404 format(a,i0,*(",",i0:))
   ! MEMBERS ( basic time values are all integers)
   write(*,101)'%year        Year................... ',event%year           ! print members of type
   write(*,101)'%month       Month.................. ',event%month
   write(*,101)'%day         Day.................... ',event%day
   write(*,101)'%tz          Timezone............... ',event%tz
   write(*,101)'%hour        Hour................... ',event%hour
   write(*,101)'%minute      Minute................. ',event%minute
   write(*,101)'%second      Second................. ',event%second
   write(*,101)'%millisecond Millisecond............ ',event%millisecond
   ! PRINT METHODS OF TYPE
   write(*,*)'Print methods of type(DATE_TIME)'
   write(*,101)'%ordinal     Ordinal day of year.... ',  event%ordinal()
   write(*,101)'%weekday     Weekday................ ',  event%weekday()
   101 format(1x,a,i0)
   ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY
   write(*,202)'%epoch      Unix epoch time........ ',  event%epoch()
   write(*,202)'%julian     Julian date............ ',  event%julian()
   202 format(1x,a,g0)
   ! FORMATTED STRINGS (many strings possible. Takes the same format string as fmtdate(3f))
   write(*,*)
   write(*,*)'Formatted Strings (%format("STRING") -- see fmtdate(3f) for format descriptions'
   write(*,303)'Short month............ ',event%format("%l")  ! abbreviated month name             %l  Dec
   write(*,303)'Month.................. ',event%format("%L")  ! full month name                    %L  December
   write(*,303)'Short week............. ',event%format("%w")  ! first three characters of weekday  %w  Sat
   write(*,303)'Week .................. ',event%format("%W")  ! weekday name                       %W  Saturday
   ! with no percent (%) characters
   write(*,303)'Calendar Time ......... ',event%format("Y-M-D h:m:s.x z")
   ! keywords with no percent (%) characters
   write(*,303)'Calendar Time ......... ',event%format('"year-month-day hour:minute:second.millisecond timezone"')
   write(*,*)event%format('Longer format.......... "%W, %L %d, %Y %H:%m:%s %N"') ! a nice friendly format
   303 format(1x,a,'"',a,'"')
   dat=event%datout()            ! convert date_time to integer array (maybe to use with module M_TIME base procedures)
   write(*,*)
   write(*,404)'DAT=',dat
   ! OVERLOADED OPERATORS (add and subtract)
   answer=event+1*86400.0d0   ! a date_time object can have seconds added
   write(*,*)answer%format('TOMORROW="%W, %L %d, %Y %H:%m:%s %N"') ! a nice friendly format
   answer=event-1*86400.0d0   ! a date_time object can have seconds subtracted
   write(*,*)answer%format('YESTERDAY=="%W, %L %d, %Y %H:%m:%s %N"') ! a nice friendly format
   ! if both operands are DATE_TIME objects a subtraction finds the time in seconds between the two dates
   write(*,*)'DIFFERENCE (subtracting one date_time from another)=',answer-event
   ! OVERLOADED OPERATORS (logical comparisons)
   ! NOTE COMPARISONS ARE PERFORMED BY CONVERTING TIMES TO INTEGER SECONDS
   write(*,*)event.eq.event   ,event.lt.event   ,event.gt.event   ,event.le.event   ,event.ge.event   ,event.ne.event
   write(*,*)event.eq.answer  ,event.lt.answer  ,event.gt.answer  ,event.le.answer  ,event.ge.answer  ,event.ne.answer
   write(*,*)answer.eq.event  ,answer.lt.event  ,answer.gt.event  ,answer.le.event  ,answer.ge.event  ,answer.ne.event
   ! %DELTA easily lets you change dates by common increments
   write(*,*)
   write(*,404)'%DELTA tests starting with date ',event%delta()
   write(*,*) event%format("                             %W, %L %d, %Y %H:%m:%s %N")
   write(*,*)'Remember years and months are not constant units'
   answer=event%delta(year=1)
   write(*,*)answer%format("FOR %%DELTA(YEAR=+1)            %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(year=-1)
   write(*,*)answer%format("FOR %%DELTA(YEAR=-1)            %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(month=24)
   write(*,*)answer%format("FOR %%DELTA(MONTH=+24)          %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(month=-24)
   write(*,*)answer%format("FOR %%DELTA(MONTH=-24)          %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(week=1)
   write(*,*)answer%format("FOR %%DELTA(WEEK=+1)            %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(week=-1)
   write(*,*)answer%format("FOR %%DELTA(WEEK=-1)            %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(day=1)
   write(*,*)answer%format("FOR %%DELTA(DAY=+1)             %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(day=-1)
   write(*,*)answer%format("FOR %%DELTA(DAY=-1)             %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(hour=4)
   write(*,*)answer%format("FOR %%DELTA(HOUR=+4)            %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(hour=-4)
   write(*,*)answer%format("FOR %%DELTA(HOUR=-4)            %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(minute=180)
   write(*,*)answer%format("FOR %%DELTA(MINUTE=+180)        %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(minute=-180)
   write(*,*)answer%format("FOR %%DELTA(MINUTE=-180)        %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(second=1800)
   write(*,*)answer%format("FOR %%DELTA(SECOND=+1800)       %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(second=-1800)
   write(*,*)answer%format("FOR %%DELTA(SECOND=-1800)       %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(millisecond=10000)
   write(*,*)answer%format("FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(millisecond=-10000)
   write(*,*)answer%format("FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(year=3,month=2,day=100,hour=200,week=-1,minute=300,second=1000,millisecond=-10000)
   write(*,*)answer%format(&amp;
   &amp;"FOR %%DELTA(year=3,month=2,day=100,hour=200,&amp;
   &amp;week=-1,minute=300,second=1000,millisecond=100000)  %W, %L %d, %Y %H:%m:%s %N")
   answer=event%delta(duration="1-20:30:40.50")
   write(*,*)answer%format("FOR %%DELTA(DURATION='1-20:30:40.50')      %W, %L %d, %Y %H:%m:%s %N")
end subroutine object_oriented
end program demo_M_time
</pre>
          <h3>Sample output of example program ...</h3>
          <p>The example from the conventional calls looks like this ...</p>
          <pre>
 Today
 ISO       2015-12-22T08:07:34.025-0300
 Friendly  Tuesday, December 22nd, 2015 08:07:34 AM
 ISO week  2015-W52-2
 Yesterday
           2015-12-21T08:07:34.025-0300
           Monday, December 21st, 2015 08:07:34 AM
           2015-W52-1
 Tomorrow
           2015-12-23T08:07:34.025-0300
           Wednesday, December 23rd, 2015 08:07:34 AM
           2015-W52-3
 Next Week
           2015-12-29T08:07:34.025-0300
           Tuesday, December 29th, 2015 08:07:34 AM
           2015-W53-2
</pre>
          <p>The example from the object-oriented calls looks like this ...</p>
<pre>
 Various initialization styles
 DEFAULT CONSTRUCTOR %FORMAT()               1970-01-01T00:00:00.000+0000
 DEFAULT CONSTRUCTOR %FORMAT("")             1970-01-01T00:00:00.000+0000
 DEFAULT CONSTRUCTOR %FORMAT(user-specified) 1970-01-01T00:00:00.000+0000
 DEFAULT CONSTRUCTOR %FORMAT("USA")          Thursday, January 1st, 1970 12:00:00 AM
 DEFAULT CONSTRUCTOR SETTING VALUES          1492-10-12T00:00:00.000+0000
 DEFAULT CONSTRUCTOR WITH PARTIAL VALUES     2016-06-11T00:00:00.000+0000
 DEFAULT CONSTRUCTOR WITH VALUES BY NAME     2016-06-11T21:09:11.500-0240
 CONSTRUCTOR WITH A DAT ARRAY                1776-07-04T00:00:00.000+0000
 CONSTRUCTOR WITH A PARTIAL DAT ARRAY        1776-07-04T20:00:00.000-0240
 Print members of type(DATE_TIME)
EVENT=2016,6,14,-240,22,22,31,253
 Year................... 2016
 Month.................. 6
 Day.................... 14
 Timezone............... -240
 Hour................... 22
 Minute................. 22
 Second................. 31
 Millisecond............ 253
 Print methods of type(DATE_TIME)
 Ordinal day of year.... 166
 Weekday................ 3
 Unix epoch time........ 1465957351.2529941
 Julian date............ 2457554.5989728356
 Formatted Strings
 Short month............ "Jun"
 Month.................. "June"
 Short week............. "Tue"
 Week .................. "Tuesday"
 Longer format.......... "Tuesday, June 14th, 2016 10:22:31 PM"
DAT=2016,6,14,-240,22,22,31,253
 TOMORROW="Wednesday, June 15th, 2016 10:22:31 PM"
 YESTERDAY=="Wednesday, June 13th, 2016 10:22:31 PM"
 DIFFERENCE (subtracting one date_time from another)=   86400.000000000000
 T F F T T F
 F T F T F T
 F F T F T T
%DELTA tests starting with date 2016,6,14,-240,22,22,31,253
                              Tuesday, June 14th, 2016 10:22:31 PM
 Remember years and months are not constant units
 FOR DELTA YEAR=+1            Wednesday, June 14th, 2017 10:22:31 PM
 FOR DELTA YEAR=-1            Sunday, June 14th, 2015 10:22:31 PM
 FOR DELTA MONTH=+24          Saturday, June 16th, 2018 10:22:31 PM
 FOR DELTA MONTH=-24          Saturday, June 14th, 2014 10:22:31 PM
 FOR DELTA WEEK=+1            Tuesday, June 21st, 2016 10:22:31 PM
 FOR DELTA WEEK=-1            Tuesday, June 7th, 2016 10:22:31 PM
 FOR DELTA DAY=+1             Wednesday, June 15th, 2016 10:22:31 PM
 FOR DELTA DAY=+1             Monday, June 13th, 2016 10:22:31 PM
 FOR DELTA HOUR=+4            Wednesday, June 15th, 2016 02:22:31 AM
 FOR DELTA HOUR=-4            Tuesday, June 14th, 2016 06:22:31 PM
 FOR DELTA MINUTE=+180        Wednesday, June 15th, 2016 01:22:31 AM
 FOR DELTA MINUTE=-180        Tuesday, June 14th, 2016 07:22:31 PM
 FOR DELTA SECOND=+1800       Tuesday, June 14th, 2016 10:52:31 PM
 FOR DELTA SECOND=-1800       Tuesday, June 14th, 2016 09:52:31 PM
 FOR DELTA MILLISECOND=+10000 Tuesday, June 14th, 2016 10:22:41 PM
 FOR DELTA MILLISECOND=-10000 Tuesday, June 14th, 2016 10:22:21 PM
 FOR DELTA ONE-OF-EACH        Sunday, November 24th, 2019 11:39:01 AM
</pre>
        </dd>
        <dt>DEFINITIONS</dt>
        <dd>
          <p>A "date_and_time" array <b>"DAT"</b> has the same format as the array of values generated by the Fortran intrinsic DATE_AND_TIME(3f). That is,
          it is an 8-element integer array containing year, month, day, Time zone difference from UTC in minutes, hour, minutes, seconds, and milliseconds
          of the second. This array represents a date on the Proleptic Gregorian Calendar.</p>The <b>Proleptic Gregorian Calendar</b> assumes the Gregorian
          Calendar existed back to the beginning of the Julian Day calendar (4713 BC). This means historic dates will often be confused, as the Julian
          Calendar was used in the USA until 1752-09-03, for example. The Gregorian Calendar was formally decreed on 1582-10-15 but was not adapted in many
          countries. The Julian Calendar was first used around 45 BC. Note that the Proleptic Gregorian Calendar includes a year zero (0). It is frequently
          used in computer software to simplify the handling of older dates. For example, it is the calendar used by MySQL, SQLite, PHP, CIM, Delphi, Python
          and COBOL. The Proleptic Gregorian Calendar is explicitly required for all dates before 1582 by ISO 8601:2004 (clause 4.3.2.1 The Gregorian
          calendar) if the partners to information exchange agree.
          <p><b>Unix Epoch Time (UET)</b> is defined as the number of seconds since 00:00:00 on January 1st. 1970, UTC.</p>
          <p>A <b>JED</b> is defined as a <b>Julian Ephemeris Date</b>. JED days start at noon (not at midnight). 4713-01-01 BC at noon is defined as JED
          0.0.</p>
          <p>If you are not familiar with them, in this context Julian Dates and Unix Epoch Times are scalar numbers that allow for easy computations using
          dates (to go back one day just subtract one from a Julian Date, for example). Since these values are generally not considered intelligible,
          routines are included to convert between these scalar values and the date array so human-readable results can be obtained.</p>
          <p><b>Coordinated Universal Time</b> (French: Temps universel coordonn'e), abbreviated as <b>UTC</b>, is the primary time standard by which the
          world regulates clocks and time. It is within about 1 second of mean solar time at 0o longitude;[1] it does not observe daylight saving time. It
          is one of several closely related successors to Greenwich Mean Time (GMT). For most purposes, UTC is considered interchangeable with GMT, but GMT
          is no longer precisely defined by the scientific community.</p>
        </dd>
        <dt>LIMITATIONS</dt>
        <dd>
          <p>Like most collections of date and time procedures M_time is <em>not</em> a high-precision library that accounts internally for leap seconds and
          relativistic effects.</p>
          <p>M_time(3f) is intended for use in the recent era and is not appropriate for use with historical dates that used some other calendar scheme such
          as the Julian Calendar. That is, you have to remember to account for conversions to other calendar systems when using historical dates.</p>
          <p>When Daylight Savings is in effect calculations will generally be correct, as the date model includes a timezone value; but you are responsible
          for ensuring dates you create use the correct timezone value or otherwise account for Daylight Savings Time as needed.</p>
          <p>Currently, dates are manipulated using the current system timezone, which can typically be set using the environment variable TZ. So if you
          desire to set the default timezone you generally set the environment variable <em>before</em> executing your program. This is compatible with
          current observed behavior for the intrinsic procedure DATE_AND_TIME(3f) with compilers I have tested with, but does not seem to be a specified
          behavior as far as the standard is concerned. That is, DATE_AND_TIME(3f) returns a vector that contains a current time zone, but does not specify
          how a current time zone can be explicitly set. Since this library is intentionally designed to complement DATE_AND_TIME(3f) it adopts the same
          behavior. A routine to let you set a default time zone could be added in the future.</p>
          <p>Note the environment variable can be set using put_environment_variable(3f) from the libGPF library:</p>
          <pre>
     use M_system, only : put_environment_variable
     call put_environment_variable('TZ','America/New_York',ierr)
</pre>
          <p>There is no warranty on this code, and it is certain to change.</p>
        </dd>
        <dt>SEE ALSO</dt>
        <dd>
          <p>The ISO-8601 standard is often used for business-related transactions.</p>
          <p>There are (of course) the C/C++ intrinsics which provide much of the same functionality that should be bindable to Fortran via the
          ISO_C_BINDING module.</p>
          <p>If you are looking for a high-precision Fortran library that is well tested for manipulating dates I would suggest looking at the NASA SPICElib
          library. If you care about Leap Seconds, Orbital Mechanics, GPS/Satellite communications, and Astronomy it is worth a look.</p>
          <p>The Fortran Wiki <a href="http://fortranwiki.org">fortranwiki.org</a> contains information on other libraries and modules that provide
          date-time procedures.</p>
        </dd>
      </dl>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>box_month(3f)</b> - [M_time] create specified month in a character array <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>box_month</b>(dat,calen)
<br />    integer,intent(in)    :: dat(8)
    character(len=21)     :: calen(8)
<br />
</pre>
      <a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      
        <b>box_month</b>(3f) uses a year and month from a date array to populate a small character array with a calendar representing the month.
      <a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">"DAT" array (an integer array of the same format as the array returned by the intrinsic <b>DATE_AND_TIME</b>(3f)) describing
            the date to be used to specify what calendar month to produce.
        <pre>
          dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds]
</pre>
            </td>
          </tr>
        </table>
      <a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      
        <table cellpadding="3">
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">calen</td>
            <td valign="bottom">returned character array holding a display of the specified month</td>
          </tr>
        </table>
                   <a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_box_month
    use M_time, only : box_month
    implicit none
    integer           :: dat(8)
    character(len=21) :: calendar(8)
       call date_and_time(values=dat)
       call box_month(dat,calendar)
       write(*,'(a)')calendar
    end program demo_box_month
<br />
</pre>results:
        <pre>
     &gt;     July 2016
     &gt;Mo Tu We Th Fr Sa Su
     &gt;             1  2  3
     &gt; 4  5  6  7  8  9 10
     &gt;11 12 13 14 15 16 17
     &gt;18 19 20 21 22 23 24
     &gt;25 26 27 28 29 30 31
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c3">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>d2j(3f)</b> - [M_time] given DAT date-time array returns Julian Date <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
        <pre>
function <b>d2j</b>(<i>dat</i>) result (<i>julian</i>)
<br />    integer,intent(in)  :: dat(8)
    real(kind=realtime) :: julian
<br />
</pre>
      <a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3><a name="3"></a>
         given DAT date-time array returns Julian Date <b>(LICENSE:PD)</b>

      <h3><a name="3">OPTIONS</a></h3>
      
        <table cellpadding="3">
          <tr valign="top">
            <td class="c4" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">
              Integer array holding a "DAT" array, similar in
              structure to the array returned by the intrinsic
              <b>DATE_AND_TIME</b>(3f):
                 <pre><i>dat</i>=[year,month,day,timezone,hour,minutes,seconds,milliseconds]</pre>
              If not present, use current time.
            </td>
          </tr>
        </table>

      <a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      
        <table cellpadding="3">
          <tr valign="top">
            <td class="c4" width="6%" nowrap="nowrap">julian</td>
            <td valign="bottom">The Julian Date.</td>
          </tr>
        </table>

      <a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_d2j
    use M_time, only : d2j
    implicit none
    integer :: dat(8)
       call date_and_time(values=dat)
       write(*,'(" Today is:",*(i0:,":"))')dat
       write(*,*)'Julian Date is ',d2j(dat)
    end program demo_d2j
<br />
</pre>results:
        <pre>
    Today is:2016:7:19:-240:2:11:50:885
    Julian Date is    2457588.7582278359
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c5">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>d2o(3f)</b> - [M_time] converts DAT date-time array to Ordinal day <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>d2o</b>(<i>dat</i>) result (<i>ordinal</i>)
<br />    integer,intent(in),optional :: dat(8)   ! date time array
    integer                     :: ordinal  ! the returned day of the year
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      
        Given a date in the form of a "DAT" array return the Ordinal Day, (ie. "the day of the year").
      <a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      
        <table cellpadding="3">
          <tr valign="top">
            <td class="c6" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Integer array holding a "DAT" array, similar in structure to the array returned by the intrinsic
            <b>DATE_AND_TIME</b>(3f):
            <pre> dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
            </td>
          </tr>
        </table>
      <a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      
        <table cellpadding="3">
          <tr valign="top">
            <td class="c6" colspan="1">ordinal</td>
            <td>The day of the year calculated for the given input date, where Jan 1st=1.</td>
          </tr>
        </table>

      <a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_d2o
    use M_time, only : d2o
    implicit none
    integer :: dat(8)
       call date_and_time(values=dat)
       write(*,'(" Today is:",*(i0:,":"))')dat
       write(*,*)'Day of year is:',d2o(dat)
<br />       ! year, month, day, timezone, hour, minute, seconds, milliseconds
       dat=[2020,12,31,-240,12,0,0,0]
       write(*,*)dat(1),' Days in year is:',d2o(dat)
<br />       dat=[2021,12,31,-240,12,0,0,0]
       write(*,*)dat(1),' Days in year is:',d2o(dat)
<br />       dat=[2022,12,31,-240,12,0,0,0]
       write(*,*)dat(1),' Days in year is:',d2o(dat)
<br />       dat=[2023,12,31,-240,12,0,0,0]
       write(*,*)dat(1),' Days in year is:',d2o(dat)
<br />       dat=[2024,12,31,-240,12,0,0,0]
       write(*,*)dat(1),' Days in year is:',d2o(dat)
<br />    end program demo_d2o
<br />
</pre>results:
        <pre>
    Today is:2016:7:19:-240:20:1:19:829
    Day of year is:         201
           2020  Days in year is:         366
           2021  Days in year is:         365
           2022  Days in year is:         365
           2023  Days in year is:         365
           2024  Days in year is:         366
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c7">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>d2u(3f)</b> - [M_time] given DAT date-time array returns Unix Epoch Time (UET starts at 0000 on 1 Jan. 1970, UTC) <b>(LICENSE:PD)</b>
      </blockquote>
      <a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>d2u</b>(<i>dat</i>) esult (<i>unixtime</i>)
<br />      integer,intent(in),optional :: dat(8)
      real(kind=realtime)         :: unixtime
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      
        Converts a DAT date-time array to a Unix Epoch Time value. Typically mathematical operations such as sums, sorting and comparison are performed with
        simple UET numeric values, and then they are converted back.
                   <a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c8" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Integer array holding a "DAT" array,
            similar in structure to the array returned by the intrinsic
            <b>DATE_AND_TIME</b>(3f):
            <pre> dat=[yekr,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
            If not present the current time is used.
            </td>
          </tr>
      </table>
      <a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c8" colspan="1" width="%6">unixtime</td>
            <td>The "Unix Epoch" time, or the number of seconds since 00:00:00 on January 1st, 1970, UTC.</td>
          </tr>
        </table>

      <a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_d2u
    use M_time, only : d2u
    implicit none
    integer           :: dat(8)
       call date_and_time(values=dat)
       write(*,'(" Today is:",*(i0:,":"))')dat
       write(*,*)'Unix Epoch time is ',d2u(dat)
    end program demo_d2u
<br />
</pre>results:
        <pre>
    Today is:2016:7:19:-240:2:0:48:561
    Unix Epoch time is    1468908048.5610321
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c9">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>d2w(3f)</b> - [M_time] calculate iso-8601 Week-numbering year date yyyy-Www-d given DAT date-time array <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="13"></a>
      <h3><a name="13">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>d2w</b>(dat,iso_year,iso_week,iso_weekday,iso_name)
<br />    integer,intent(in)              :: dat(8)     ! input date array
    integer,intent(out)             :: iso_year, iso_week, iso_weekday
    character(len=10),intent(out)   :: iso_name
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>

        Given a "DAT" array defining a date and time, return the ISO-8601 Week in two formats -- as three integer values defining the ISO year, week of year
        and weekday; and as a string of the form "yyyy-Www-d".
      <a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      
        <table cellpadding="3">
          <tr valign="top">
            <td class="c10" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">"DAT" array (an integer array of the same format as the array returned by the intrinsic <b>DATE_AND_TIME</b>(3f)) describing
            the date, which is the basic time description used by the other <b>M_time</b>(3fm) module procedures.</td>
          </tr>
        </table>

      <a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c10" colspan="1" width="%6">iso_year</td>
            <td>ISO-8601 year number for the given date</td>
          </tr>
          <tr valign="top">
            <td class="c10" colspan="1" width="%6">iso_week</td>
            <td>ISO-8601 week number for the given date</td>
          </tr>
          <tr valign="top">
            <td class="c10" colspan="1" width="%6">iso_weekday</td>
            <td>ISO-8601 weekday number for the given date</td>
          </tr>
          <tr valign="top">
            <td class="c10" colspan="1" width="%6">iso_name</td>
            <td>ISO-8601 Week string for the data in the form "yyyy-Www-d".</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_d2w
    use M_time, only : d2w
    implicit none
    integer           :: dat(8)     ! input date array
    integer           :: iso_year, iso_week, iso_weekday
    character(len=10) :: iso_name
<br />       call date_and_time(values=dat)
       call d2w(dat,iso_year,iso_week,iso_weekday,iso_name)
       write(*,'("ISO-8601 Week:   ",a)')iso_name
       write(*,'(a,i0)')'ISO-8601 year    ',iso_year
       write(*,'(a,i0)')'ISO-8601 week    ',iso_week
       write(*,'(a,i0)')'ISO-8601 weekday ',iso_weekday
    end program demo_d2w
</pre>
        <p>results:</p>
        <pre>
    ISO-8601 Week:   2016-W29-1
    ISO-8601 year    2016
    ISO-8601 week    29
    ISO-8601 weekday 1
<br />
</pre>
      </blockquote><a name="6"></a>
      <h3><a name="6">DEFINITION</a></h3>
        The ISO-8601 date and time standard was issued by the International Organization for Standardization (ISO). It is used (mainly) in government and
        business for fiscal years, as well as in timekeeping. The system specifies a week year atop the Gregorian calendar by defining a notation for
        ordinal weeks of the year.
        <p>An ISO week-numbering year (also called ISO year informally) has 52 or 53 full weeks. That is 364 or 371 days instead of the usual 365 or 366
        days. The extra week is referred to here as a leap week, although ISO-8601 does not use this term. Weeks start with Monday. The first week of a year
        is the week that contains the first Thursday of the year (and, hence, always contains 4 January). ISO week year numbering therefore slightly
        deviates from the Gregorian for some days close to January 1st.</p>
      <a name="7"></a>
      <h3><a name="7">CALCULATION</a></h3>
        The ISO-8601 week number of any date can be calculated, given its ordinal date (i.e. position within the year) and its day of the week.
      <a name="8"></a>
      <h3><a name="8">METHOD</a></h3>
      
        Using ISO weekday numbers (running from 1 for Monday to 7 for Sunday), subtract the weekday from the ordinal date, then add 10. Divide the result by
        7. Ignore the remainder; the quotient equals the week number. If the week number thus obtained equals 0, it means that the given date belongs to the
        preceding (week-based) year. If a week number of 53 is obtained, one must check that the date is not actually in week 1 of the following year.
        <p>These two statements are assumed true when correcting the dates around January 1st:</p>
        <table cellpadding="3">
          <!-- tsb: These two statements are assumed true when correcting the dates around January 1st:
 -->
          <tr valign="top">
            <td width="3%">o</td>
            <td>The number of weeks in a given year is equal to the corresponding week number of 28 December.</td>
          </tr>
          <tr valign="top">
            <td width="3%">o</td>
            <td>January 4th is always in the first week.</td>
          </tr>
        </table>
      <a name="9"></a>
      <h3><a name="9">ISO_NAME</a></h3>
      
        Week date representations are in the format YYYYWww-D.
        <table cellpadding="3">
          <!-- tsb: Week date representations are in the format YYYYWww-D.
 -->
          <tr valign="top">
            <td width="3%">o</td>
            <td>[YYYY] indicates the ISO week-numbering year which is slightly different from the traditional Gregorian calendar year.</td>
          </tr>
          <tr valign="top">
            <td width="3%">o</td>
            <td>[Www] is the week number prefixed by the letter W, from W01 through W53.</td>
          </tr>
          <tr valign="top">
            <td width="3%">o</td>
            <td>[D] is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</td>
          </tr>
        </table>
      <p>For example, the Gregorian date 31 December 2006 corresponds to the Sunday of the 52nd week of 2006, and is written</p>
      <pre>
    2006-W52-7 (extended form)
    or
    2006W527 (compact form).
<br />
</pre><a name="10"></a>
      <h3><a name="10">REFERENCE</a></h3>
      <blockquote>
        From Wikipedia, the free encyclopedia 2015-12-19
      </blockquote><a name="11"></a>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c11">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>date_to_julian(3f)</b> - [M_time] converts DAT date-time array to Julian Date <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <a name="8"></a>

      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>

        <pre>
subroutine <b>date_to_julian</b>(dat,juliandate,ierr)
<br />    integer,intent(in)               :: dat(8)
    real(kind=realtime),intent(out)  :: juliandate
    integer,intent(out)              :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Converts a DAT date-time array to a Unix Epoch Time (UET) value. UET is the number of seconds since 00:00 on January 1st, 1970, UTC.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c12" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Integer array holding a "DAT" array,
                similar in structure to the array returned by the intrinsic
                <b>DATE_AND_TIME</b>(3f):
                <pre> dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
            </td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c12" colspan="1" width="%6">juliandate</td>
            <td>A Julian Ephemeris Date (JED) is the number of days since noon (not midnight) on January 1st, 4713 BC.</td>
          </tr>
          <tr valign="top">
            <td class="c12" width="6%" nowrap="nowrap">ierr</td>
            <td valign="bottom">Error code. If 0 no error occurred.</td>
          </tr>
        </table>

      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample Program:
        <pre>
    program demo_date_to_julian
    use M_time, only : date_to_julian,realtime
    implicit none
    integer             :: dat(8)
    real(kind=realtime) :: juliandate
    integer             :: ierr
       ! generate DAT array
       call date_and_time(values=dat)
       ! show DAT array
       write(*,'(" Today is:",*(i0:,":"))')dat
       ! convert DAT to Julian Date
       call date_to_julian(dat,juliandate,ierr)
       write(*,*)'Julian Date is ',juliandate
       write(*,*)'ierr is ',ierr
    end program demo_date_to_julian
<br />
</pre>results:
        <pre>
    Today is:2016:7:19:-240:11:3:13:821
    Julian Date is    2457589.1272432986
    ierr is            0
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c13">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>date_to_unix(3f)</b> - [M_time] converts DAT date-time array to Unix Epoch Time <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>date_to_unix</b>(dat,unixtime,ierr)
<br />    integer,intent(in)               :: dat(8)
    real(kind=realtime),intent(out)  :: unixtime
    integer,intent(out)              :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Converts a DAT date-time array to a UET (Unix Epoch Time).</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c14" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Integer array holding a "DAT" array, similar in structure to the array returned by the intrinsic
            <b>DATE_AND_TIME</b>(3f):
        <pre> dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
            </td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c14" colspan="1" width="6%" >unixtime</td>
            <td>The "Unix Epoch" time, or the number of seconds since 00:00:00 on January 1st, 1970, UTC.</td>
          </tr>
          <tr valign="top">
            <td class="c14" width="6%" nowrap="nowrap">ierr</td>
            <td valign="bottom">Error code. If 0 no error occurred.</td>
          </tr>
        </table>

      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_date_to_unix
    use M_time, only : date_to_unix, realtime
    implicit none
    integer             :: dat(8)
    real(kind=realtime) :: unixtime
    integer             :: ierr
       call date_and_time(values=dat)
       write(*,'(" Today is:",*(i0:,":"))')dat
       call date_to_unix(dat,unixtime,ierr)
       write(*,*)'Unix Epoch time is ',unixtime
       write(*,*)'ierr is ',ierr
    end program demo_date_to_unix
<br />
</pre>results:
        <pre>
    Today is:2016:7:18:-240:23:44:20:434
    Unix Epoch time is    1468899860.4340105
    ierr is            0
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<body?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="HTML Tidy for Cygwin (vers 25 March 2009), see www.w3.org" />

  <title></title>
</head>

<div><P style="page-break-before: always">
  <a name="top" id="top"></a>

  <div id="Container">
    <div id="Content">
      <div class="c15"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>days2sec(3f)</b> - [M_time] convert string of form [[-]dd-]hh:mm:ss.nn to seconds <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="8"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>days2sec</b>(<i>str</i>) <b>result</b>(<i>time</i>)
<br />    character(len=*),intent(in)       :: str
    real(kind=realtime)               :: time
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        Given a string representing a duration of the form

        <table cellpadding="3">
          <tr valign="top">
            <td class="c16" colspan="2">[-][[[dd-]hh:]mm:]ss</td>
          </tr>
        </table>or

        <table cellpadding="3">
          <tr valign="top">
            <td>[NNd][NNh][NNm][NNs][NNw]</td>
          </tr>
        </table>return a value representing seconds

        <table cellpadding="3">
          <tr>
            <td>
              If "dd-" is present, units for the numbers are assumed to proceed from day to hour to minute to second. But if no day is present, the units
              are assumed to proceed from second to minutes to hour from left to right. That is ...
              <pre>
        [-]dd-hh:mm:ss
        [-]dd-hh:mm
        [-]dd-hh
        hh:mm:ss
        mm:ss
        ss
        
</pre>Where dd is days, hh hours, mm minutes and ss seconds. A decimal fraction is supported on the seconds (Actually, any of the numeric values may
represent positive floating point numbers). Spaces are ignored.
            </td>
          </tr>
        </table>[NNd][NNh][NNm][NNs][NNw]

        <table width="100%" cellpadding="3">
          <tr>
            <td width="6%"></td>

            <td>
              Simple numeric values may also be used with unit suffixes; where s,m,h, or d represents seconds, minutes, hours or days and w represents a
              week. Allowed aliases for w,d,h,m, and s units are
              <pre>
                 d -  days,day
                 m -  minutes,minute,min,mins
                 h -  hours,hour,hr,hrs
                 s -  seconds,second,sec,secs
                 w -  week, weeks, wk, wks 
</pre>The numeric values may represent floating point numbers.

              <p>Spaces, commas and case are ignored.</p>
            </td>

            <td></td>
          </tr>
        </table>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c17" width="6%" nowrap="nowrap">str</td>

            <td valign="bottom">string of the general form dd-hh:mm:ss.nn or [NNd][NNh][NNm][NNs][NNw]</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURNS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c17" width="6%" nowrap="nowrap">time</td>

            <td valign="bottom">the number of seconds represented by the input string</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
    program demo_days2sec
    use M_time, only : days2sec
    implicit none
       write(*,*)days2sec('1-12:04:20')
       write(*,*)'one second ',days2sec('1')
       write(*,*)'one minute ',days2sec('1:00')
       write(*,*)'one hour ',days2sec('1:00:00')
       write(*,*)'one day ',days2sec('1-00:00:00')
       write(*,*)nint(days2sec(' 1-12:04:20              ')) .eq. 129860
       write(*,*)nint(days2sec(' 1.5 days                ')) .eq. 129600
       write(*,*)nint(days2sec(' 1.5 days 4hrs 30minutes ')) .eq. 145800
       write(*,*)nint(days2sec(' 1.5d                    ')) .eq. 129600
       write(*,*)nint(days2sec(' 1d2h3m4s                ')) .eq. 93784
       ! duplicates
       write(*,*)nint(days2sec(' 1d1d1d                  ')) .eq. 259200
       ! negative values
       write(*,*)nint(days2sec(' 4d-12h                  ')) .eq. 302400
    end program demo_days2sec
<br />
</pre>Results:
        <pre>
    129860.00000000000
    one second    1.0000000000000000
    one minute    60.000000000000000
    one hour    3600.0000000000000
    one day    86400.000000000000
    T
    T
    T
    T
    T
    T
    T
</pre>
      </blockquote>
    </div>
  </div>
</div>
</html>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c18">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>dow(3f)</b> - [M_time] given a date-time array DAT return the day of the week <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>dow</b>(<i>values</i>, <i>weekday</i>, <i>day</i>, <i>ierr</i>)
<br />    integer,intent(in) :: values(8)
    integer,intent(out),optional :: weekday
    character(len=*),intent(out),optional :: day
    integer,intent(out),optional :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Given a date array DAT return the <i>day</i> of the week as a number and a name, Mon=1.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c19" width="6%" nowrap="nowrap">values</td>
            <td valign="bottom">"DAT" array (an integer array of
               the same format as the array returned by the intrinsic
               <b>DATE_AND_TIME</b>(3f)) describing
               the date to be used to calculate the <i>day</i> of the week.
            </td>
          </tr>
      
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c19" colspan="1" width="6%" >weekday</td>
            <td>The numeric <i>day</i> of the week, starting with Monday=1. Optional.</td>
          </tr>

          <tr valign="top">
            <td class="c19" width="6%" nowrap="nowrap">day</td>
            <td valign="bottom">The name of the <i>day</i> of the week. Optional.</td>
          </tr>

          <tr valign="top">
            <td class="c19" width="6%" nowrap="nowrap">ierr</td>
            <td valign="bottom">
              Error code
              <table width="100%" cellpadding="3">
                <!-- tsb: Error code
 -->
                <tr valign="top">
                  <td width="3%">0</td>
                  <td> correct</td>
                </tr>
                <tr valign="top">
                  <td width="3%">-1</td>
                  <td>invalid input date</td>
                </tr>
                <tr valign="top">
                  <td width="3%">-2</td>
                  <td>neither <i>day</i> nor <i>weekday</i> return <i>values</i> were requested.</td>
                </tr>
              </table>
              If the error code is not returned and an error occurs, the program is stopped.
            </td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
<pre>
    program demo_dow
    use M_time, only : dow
    implicit none
    integer          :: dat(8)     ! input date array
    integer          :: weekday
    character(len=9) :: day
    integer          :: ierr
      call date_and_time(values=dat)
      call dow(dat, weekday, day, ierr)
      write(*,'(a,i0)')'weekday=',weekday
      write(*,'(a,a)')'day=',trim(day)
      write(*,'(a,i0)')'ierr=',ierr
    end program demo_dow
</pre>
        <p>results:</p>
<pre>
    weekday=1
    day=Monday
    ierr=0
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c20">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>easter(3f)</b> - [M_time] calculate date for Easter given a year <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="6"></a>
      <h3><a name="6">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>easter</b>(year,dat)
<br />    integer, intent(in)   :: year
    integer, intent(out)  :: dat
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        The Date of Easter (Sunday)
        <p>The algorithm is due to J.<b>-M</b>. Oudin (1940) and is reprinted in the Explanatory Supplement to the Astronomical Almanac, ed. P. K.
        Seidelmann (1992). See Chapter 12, "Calendars", by L. E. Doggett.</p>
        <p>The following are dates of Easter from 1980 to 2024:</p>
        <pre>
       1980  April  6        1995  April 16        2010  April  4
       1981  April 19        1996  April  7        2011  April 24
       1982  April 11        1997  March 30        2012  April  8
       1983  April  3        1998  April 12        2013  March 31
       1984  April 22        1999  April  4        2014  April 20
       1985  April  7        2000  April 23        2015  April  5
       1986  March 30        2001  April 15        2016  March 27
       1987  April 19        2002  March 31        2017  April 16
       1988  April  3        2003  April 20        2018  April  1
       1989  March 26        2004  April 11        2019  April 21
       1990  April 15        2005  March 27        2020  April 12
       1991  March 31        2006  April 16        2021  April  4
       1992  April 19        2007  April  8        2022  April 17
       1993  April 11        2008  March 23        2023  April  9
       1994  April  3        2009  April 12        2024  March 31
<br />
</pre>N.B. The date of Easter for the Eastern Orthodox Church may be different.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c21" width="6%" nowrap="nowrap">year</td>
            <td valign="bottom">Year for which to calculate day that Easter falls on</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">RESULTS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c21" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Date array for noon on Easter for the specified year</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        <p>Sample program:</p>
        <pre>
   program demo_easter
   use M_time, only : easter, fmtdate
   implicit none
   integer :: year
   integer :: dat(8) ! year,month,day,tz,hour,minute,second,millisecond
     call date_and_time(values=dat)  ! get current year
     year=dat(1)
     call easter(year, dat)
     write(*,*)fmtdate(dat,&amp;
     "Easter day: the %d day of %L in the year of our Lord %Y")
   end program demo_easter
<br />
</pre>Sample output:
        <pre>
   Easter day: the 16th day of April in the year of our Lord 2017
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c22">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>fmtdate(3f)</b> - [M_time] given DAT date-time array return date as string using specified format <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>fmtdate</b>(values,format) RESULT (<i>timestr</i>)
<br />    integer,dimension(8),intent(in)      :: values
    character(len=*),intent(in),optional :: format
    character(len=:),allocatable         :: timestr
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        The <b>fmtdate</b>(3f) procedure lets you reformat a DAT array in many common formats using a special string containing macro names beginning with
        '%'. To see the allowable macros call or see the <b>fmtdate_usage</b>(3f) routine.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c23" width="6%" nowrap="nowrap">values</td>
            <td valign="bottom">
              date in a "DAT" array, which is the same format as the values returned by the intrinsic <b>DATE_AND_TIME</b>(3f).
              <p>dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds]</p>
            </td>
          </tr>
          <tr valign="top">
            <td class="c23" width="6%" nowrap="nowrap">format</td>
            <td valign="bottom">string describing how to format the "DAT" array. For a complete description of the formatting macros supported see
            <b>fmtdate_usage</b>(3f).</td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c24" colspan="1" width="6%" >timestr</td>
            <td>formatted output string representing date</td>
          </tr>
        </table>
      </blockquote>

      <a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_fmtdate
    use M_time, only : fmtdate
    implicit none
    integer :: dat(8)
       call date_and_time(values=dat)
       write(*,*)fmtdate(dat,"current date: %w, %l %d, %Y %H:%m:%s %N")
       call showme()
    contains
    subroutine showme()
       use M_time, only : fmtdate_usage
       call fmtdate_usage() ! see all formatting options
    end subroutine showme
    end program demo_fmtdate
<br />
</pre>results:
        <pre>
      The current date is Sun, Jul 17th, 2016 01:21:35 PM
       ::
       :: An up-to-date description of all the
       :: formatting options will appear here
       ::
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c25">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>fmtdate_usage(3f)</b> - [M_time] display macros recognized by <b>fmtdate</b>(3f) and <b>now</b>(3f) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="7"></a>
      <h3><a name="7">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>fmtdate_usage</b>(<i>indent</i>)
<br />    integer,intent(in),optional      :: indent
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>The <b>fmtdate_usage</b>(3f) subroutine displays the formatting options available for use in procedures such as <b>fmtdate</b>(3f) and
        <b>now</b>(3f). It is typically used to produce up-to-date help text in commands that use the <b>M_time</b>(3fm) module, so that the formatting
        information only needs maintained in one place (this routine) and is easily displayed so users can quickly obtain a description of the formatting
        macros.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c26" width="6%" nowrap="nowrap">indent</td>
            <td valign="bottom">how many spaces to prefix the output with, so that calling programs can position the output. Default for this optional
            parameter is three (3).</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample Program:
        <pre>
    program demo_fmtdate_usage
    use M_time, only : fmtdate_usage
    implicit none
       call fmtdate_usage() ! see all formatting options
    end program demo_fmtdate_usage
<br />
</pre>results (actually call the routine to ensure this is up to date):
        <pre>
    Description                                        Example
<br />    Base time array:
    (1) %Y -- year, yyyy                                2016
    (2) %M -- month of year, 01 to 12                   07
    (3) %D -- day of month, 01 to 31                    29
        %d -- day of month, with suffix (1st, 2nd,...)  29th
    (4) %Z -- minutes from UTC                          -0240
        %z -- -+hh:mm from UTC                          -04:00
        %T -- -+hhmm  from UTC                          -0400
    (5) %h -- hours, 00 to 23                           10
        %H -- hour (1 to 12, or twelve-hour clock)      10
        %N -- midnight&lt; AM &lt;=noon; noon&lt;= PM &lt;midnight  AM
    (6) %m -- minutes, 00 to 59                         54
    (7) %s -- sec, 00 to 59                             08
    (8) %x -- milliseconds 000 to 999                   521
    Conversions:
        %E -- Unix Epoch time                           1469804048.5220029
        %e -- integer value of Unix Epoch time          1469804049
        %J -- Julian  date                              2457599.121
        %j -- integer value of Julian Date(Julian Day)  2457599
        %O -- Ordinal day (day of year)                 211
        %o -- Whole days since Unix Epoch date          17011
        %U -- day of week, 1..7 Sunday=1                6
        %u -- day of week, 1..7 Monday=1                5
        %i -- ISO week of year 1..53                    30
        %I -- iso-8601 week-numbering date(yyyy-Www-d)  2016-W30-5
     Names:
        %l -- abbreviated month name                    Jul
        %L -- full month name                           July
        %w -- first three characters of weekday         Fri
        %W -- weekday name                              Friday
        %p -- phase of moon                             New
        %P -- percent of way from new to full moon      -1%
     Literals:
        %% -- a literal %                               %
        %t -- tab character
        %b -- blank character
        %B -- exclamation(bang) character
        %n -- new line (system dependent)
        %q -- single quote (apostrophe)
        %Q -- double quote
     Program timing:
        %c -- CPU_TIME(3f) output                       .21875000000000000
        %C -- number of times this routine is used      1
        %S -- seconds since last use of this format     .0000000000000000
        %k -- time in seconds from SYSTEM_CLOCK(3f)     723258.812
        %K -- time in clicks from SYSTEM_CLOCK(3f)      723258812
<br />
</pre>If no percent (%) is found in the format one of several alternate substitutions occurs.
        <p>If the format is composed entirely of one of the following keywords the following substitutions occur:</p>
        <pre>
     "iso-8601",
     "iso"        ==&gt; %Y-%M-%DT%h:%m:%s%z
     "iso-8601W",
     "isoweek"    ==&gt; %I 2016-W30-5
     "sql"        ==&gt; "%Y-%M-%D %h:%m:%s.%x"
     "sqlday"     ==&gt; "%Y-%M-%D"
     "sqltime"    ==&gt; "%h:%m:%s.%x"
     "rfc-2822"   ==&gt; %w, %D %l %Y %h:%m:%s %T
     "rfc-3339"   ==&gt; %Y-%M-%DT%h:%m:%s%z
     "date"       ==&gt; %w %l %D %h:%m:%s UTC%z %Y
     "short"      ==&gt; %w, %l %d, %Y %H:%m:%s %N UTC%z
     "long"," "   ==&gt; %W, %L %d, %Y %H:%m:%s %N UTC%z
     "suffix"     ==&gt; %Y%D%M%h%m%s
     "formal"     ==&gt; The %d of %L %Y
     "lord"       ==&gt; the %d day of %L in the year of our Lord %Y
     "easter"     ==&gt; FOR THE YEAR OF THE CURRENT DATE:
                      Easter day: the %d day of %L in the year of our Lord %Y
     "all"        ==&gt; A SAMPLE OF DATE FORMATS
<br />
</pre>otherwise the following words are replaced with the most common macros:
        <pre>
      year     %Y  2016
      month    %M  07
      day      %D  29
      hour     %h  10
      minute   %m  54
      second   %s  08
      epoch    %e  1469804049
      julian   %j  2457599
      ordinal  %O  211
      weekday  %u  5
<br />
</pre>if none of these keywords are found then every letter that is a macro is assumed to have an implied percent in front of it. For example:
        <pre>
      YMDhms ==&gt; %Y%M%D%h%m%s ==&gt; 20160729105408
</pre>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c27">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>guessdate(3f)</b> - [M_time] reads in a date, in various formats <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="6"></a>
      <h3><a name="6">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>guessdate</b>(anot,dat)
<br />    character(len=*),intent(in) :: anot
    integer,intent(out)         :: dat(8)
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Read in strings and except for looking for month names remove non-numeric characters and try to convert a string assumed to represent a date to a
        date-time array.</p>
        <p>Years should always be expressed as four-digit numbers, and except for the special format yyyy-mm-dd the day should come after the year. Named
        months are preferred. If ambiguous the order is assumed to be day - month - year. Times are assumed to be of the form HH:MM:SS</p>
        <p>It is planned that this routine will be superseded. As an alternative, a C routine exists in the standard C libraries that allows for expansive
        features when reading dates that can be called via the ISO_C_BINDING interface.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c28" width="6%" nowrap="nowrap">anot</td>
            <td valign="bottom">A string assumed to represent a date including a year, month and day.</td>
          </tr>
          <tr valign="top">
            <td class="c28" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Integer array holding a "DAT" array, similar in structure to the array returned by the intrinsic
            <b>DATE_AND_TIME</b>(3f):
            <pre> dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
            </td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_guessdate
    use M_time, only : guessdate, fmtdate
    implicit none
    character(len=20),allocatable :: datestrings(:)
    character(len=:),allocatable  :: answer
    integer                       :: dat(8)
    integer                       :: i
       datestrings=[ &amp;
       &amp; 'January 9th, 2001   ',&amp;
       &amp; ' Tue Jul 19 2016    ',&amp;
       &amp; ' 21/12/2016         ',&amp;
       &amp; ' 4th of Jul 2004    ' ]
       do i=1,size(datestrings)
          write(*,'(a)')repeat('-',80)
          write(*,*)'TRYING ',datestrings(i)
          call guessdate(datestrings(i),dat)
          write(*,*)'DAT ARRAY ',dat
          answer=fmtdate(dat)
          write(*,*)'FOR '//datestrings(i)//' GOT '//trim(answer)
       enddo
    end program demo_guessdate
<br />
</pre>results:
        <pre>
    ---------------------------------------------------------------------
    TRYING January 9th, 2001
    DAT ARRAY         2001  1  9   -240    0   0   0    0
    FOR January 9th, 2001    GOT Tuesday, January 9th, 2001 12:00:00 AM
    ---------------------------------------------------------------------
    TRYING  Tue Jul 19 2016
    DAT ARRAY         2016  7  19  -240    0   0   0    0
    FOR  Tue Jul 19 2016     GOT Tuesday, July 19th, 2016 12:00:00 AM
    ---------------------------------------------------------------------
    TRYING  21/12/2016
    DAT ARRAY         2016  12 21  -240    0   0   0    0
    FOR  21/12/2016          GOT Wednesday, December 21st, 2016 12:00:00 AM
    ---------------------------------------------------------------------
    TRYING  4th of Jul 2004
    DAT ARRAY         2004  7  4   -240    0   0   0    0
    FOR  4th of Jul 2004     GOT Sunday, July 4th, 2004 12:00:00 AM
<br />
</pre>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c29">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>j2d(3f)</b> - [M_time] given a JED (Julian Ephemeris Date) returns a date-time array DAT. <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>j2d</b>(<i>julian</i>) result (<i>dat</i>)
<br />    real(kind=realtime),intent(in),optional :: julian
    integer                                 :: dat(8)
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>Converts a Julian Ephemeris Date to a DAT date-time array.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c30" width="6%" nowrap="nowrap">julian</td>
            <td valign="bottom">A Julian Ephemeris Date (JED) is the number of days since noon (not midnight) on January 1st, 4713 BC. If not present, use
            current time.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c30" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Integer array holding a "DAT" array, similar in structure to the array returned by the intrinsic
            <b>DATE_AND_TIME</b>(3f):
        <pre> dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
            </td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_j2d
    use M_time, only : j2d, d2j, fmtdate, realtime
    implicit none
    real(kind=realtime) :: today
    integer :: dat(8)
       call date_and_time(values=dat) ! get the date using intrinsic
       today=d2j(dat)                  ! convert today to Julian Date
       write(*,*)'Today=',fmtdate(j2d(today))
       ! math is easy with Julian Days and Julian Dates
       write(*,*)'Yesterday=',fmtdate(j2d(today-1.0d0))
       write(*,*)'Tomorrow=',fmtdate(j2d(today+1.0d0))
    end program demo_j2d
<br />
</pre>results:
        <pre>
    Today=Tuesday, July 19th, 2016 08:48:20 AM
    Yesterday=Monday, July 18th, 2016 08:48:20 AM
    Tomorrow=Wednesday, July 20th, 2016 08:48:20 AM
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c31">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>julian_to_date(3f)</b> - [M_time] converts a <b>JED</b>(Julian Ephemeris Date) to a DAT date-time array. <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>julian_to_date</b>(julian,dat,ierr)
<br />    real(kind=realtime),intent(in) :: julian
    integer,intent(out)            :: dat(8)
    integer,intent(out)            :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Converts a Unix Epoch Time (UET) value to a DAT date-time array. UET is the number of seconds since 00:00 on January 1st, 1970, UTC.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c32" width="6%" nowrap="nowrap">julian</td>
            <td valign="bottom">Julian Date (days)</td>
          </tr>
          <tr valign="top">
            <td class="c32" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Integer array holding a "DAT" array,
                similar in structure to the array returned by the intrinsic
                <b>DATE_AND_TIME</b>(3f):
                <pre> dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
            </td>
          </tr>

          <tr valign="top">
            <td class="c32" width="6%" nowrap="nowrap">ier</td>
            <td valign="bottom">0 for successful execution</td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c32" colspan="1" width="6%" >unixtime</td>
            <td>The "Unix Epoch" time, or the number of seconds since 00:00:00 on January 1st, 1970, UTC.</td>
          </tr>

          <tr valign="top">
            <td class="c32" width="6%" nowrap="nowrap">ierr</td>
            <td valign="bottom">Error code. If 0 no error occurred.</td>
          </tr>

        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
    program demo_julian_to_date
    use M_time, only : julian_to_date, fmtdate, realtime
    implicit none
    real(kind=realtime)     :: juliandate
    integer                 :: dat(8)
    integer                 :: ierr
       ! set sample Julian Date
       juliandate=2457589.129d0
       ! create DAT array for this date
       call julian_to_date(juliandate,dat,ierr)
       write(*,*)'Sample Date=',fmtdate(dat)
       ! go back one day
       call julian_to_date(juliandate-1.0d0,dat,ierr)
       write(*,*)'Day Before =',fmtdate(dat)
       ! go forward one day
       call julian_to_date(juliandate+1.0d0,dat,ierr)
       write(*,*)'Day After  =',fmtdate(dat)
    end program demo_julian_to_date
<br />
</pre>results:
        <pre>
    Sample Date=Tuesday, July 19th, 2016 11:05:45 AM UTC-04:00
    Day Before =Monday, July 18th, 2016 11:05:45 AM UTC-04:00
    Day After  =Wednesday, July 20th, 2016 11:05:45 AM UTC-04:00
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c33">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>mo2d(3f)</b> - [M_time] given month name return DAT date-time array for beginning of that month in specified year <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>mo2d</b>(<i>month_name</i>) result (<i>dat</i>)
<br />       character(len=*),intent(in) :: month_name
       integer                     :: dat(8)
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Given a Common Calendar month name, return the date as a "DAT" array for the 1st day of the month. An optional year may be specified. The year
        defaults to the current year.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c34" colspan="1" width="%6">month_name</td>
            <td>A string representing a Common Calendar month name.</td>
          </tr>
          <tr valign="top">
            <td class="c35" width="6%" nowrap="nowrap">year</td>
            <td valign="bottom">Optional year. Defaults to current year</td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c34" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">An integer array that has the same structure as the array returned by the Fortran intrinsic <b>DATE_AND_TIME</b>(3f).</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_mo2d
    use M_time, only : mo2d
    implicit none
       write(*,'(*(i0:,":"))')mo2d('March')
    end program demo_mo2d
<br />
</pre>results:
        <pre>
      2016:3:1:-240:0:0:0:0
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c36">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>mo2v(3f)</b> - [M_time] given month name return month number (1-12) of that month <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>mo2v</b>(<i>month_name</i>) <b>result</b>(<i>imonth</i>)
<br />     character(len=*),intent(in):: month_name ! month name
     integer                    :: imonth     ! month number
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Given a string representing the name or abbreviation of a Gregorian Calendar month return a number representing the position of the month in the
        calendar starting with 1 for January and ending with 12 for December.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c37" colspan="1" width="%6">month_name</td>
            <td>name or abbreviation of month. Case is ignored Once
                enough characters are found to uniquely identify a month
                the rest of the name is
                ignored.
            </td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c37" width="6%" nowrap="nowrap">imonth</td>
            <td valign="bottom">month number returned. If the name is not recognized a <b>-1</b> is returned.</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_mo2v
    use M_time, only : mo2v
    implicit none
       write(*,*)mo2v("April")
       write(*,*)mo2v('Apr')
       ! NOTE: still matches September, as "SE" was enough
       write(*,*)mo2v('sexember')
       write(*,*)mo2v('unknown')  ! returns -1
    end program demo_mo2v
<br />
</pre>results:
        <pre>
      &gt;  4
      &gt;  4
      &gt;  9
      &gt; -1
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c38">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>moon_fullness(3f)</b> - [M_time] return percentage of moon phase from new to full <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>moon_fullness</b>(<i>datin</i>)
<br />   integer,intent(in)            :: datin(8)
   integer                       :: moon_fullness
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        <p>This procedure is used to support the %P field descriptor for the <b>fmtdate</b>(3f) routine.</p>
        <p>The moon circles the earth every 29.530588853 days on average, so pick a starting point and count. A new moon occurred at January 6, 2000, 18:14
        UTC. Then it is easy to count the number of days since the last new moon. This is an approximate calculation.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c39" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">DAT Date array describing input date</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">RESULTS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c39" colspan="1" width="%6">moon_fullness</td>
            <td>0 is a new or dark moon, 100 is a full moon, + for waxing and - for waning.</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLES</a></h3>
      <blockquote>
        Sample:
        <pre>
   program demo_moon_fullness
   use M_time, only : now
   use M_time, only : phase_of_moon
   use M_time, only : moon_fullness
   implicit none
   integer             :: dat(8)
      ! generate DAT array
      call date_and_time(values=dat)
      ! show DAT array
      write(*,'(" Today is:",*(i0:,":"))')dat
      ! the %p and %P fields are supported by fmtdate(3f)
      write(*,*)now('The phase of the moon is %p, with a fullness of %P')
      write(*,'(1x,*(a))',advance='no')'The phase of the moon is ',trim( phase_of_moon(dat)),','
      write(*,'(1x,a,i0,a)')'with a fullness of ', moon_fullness(dat),'%'
   end program demo_moon_fullness
<br />
</pre>Sample output:
        <pre>
    Today is:2018:11:3:-240:20:18:44:245
    The phase of the moon is Waning crescent, with a fullness of -30%
    The phase of the moon is Waning crescent, with a fullness of -30%
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c40">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>now(3f)</b> - [M_time] return string representing current time given format <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>now</b>(<i>format</i>) RESULT (<i>timestr</i>)
<br />    character(len=*),intent(in)     :: format  ! input format string
    character(len=:),allocatable    :: timestr ! formatted date
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        The <b>now</b>(3f) function is a call to the <b>fmtdate</b>(3f) function using the current date and time. That is, it is a convenient way to print
        the current date and time.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c41" width="6%" nowrap="nowrap">format</td>
            <td valign="bottom">string describing how to <i>format</i> the current date and time. For a complete description of the formatting macros
            supported see <b>fmtdate_usage</b>(3f).</td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c41" colspan="1" width="%6">timestr</td>
            <td>formatted output string representing date</td>
          </tr>
        </table>

      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample Program:
        <pre>
    program demo_now
    use M_time, only : now
    implicit none
       write(*,*)now("The current date is %w, %l %d, %Y %H:%m:%s %N")
       call showme()
    contains
    subroutine showme() ! see all formatting options
    use M_time, only : fmtdate_usage
       call fmtdate_usage() ! see all formatting options
    end subroutine showme
<br />    end program demo_now
<br />
</pre>results:
        <pre>
      The current date is Sun, Jul 17th, 2016 01:21:35 PM
       ::
       :: description of all formatting options will appear here
       ::
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c42">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>o2d(3f)</b> - [M_time] converts Ordinal day to DAT date-time array <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>o2d</b>(ordinal,[year]) result (<i>dat</i>)
<br />    integer,intent(in) :: ordinal  ! the day of the year
    integer,optional   :: year     ! year
    integer            :: dat(8)   ! date time array
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Given an Ordinal day of the year return a date in the form of a "DAT" array.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c43" colspan="1" width="%6">ordinal</td>
            <td>The day of the year for the given year, where Jan 1st=1.</td>
          </tr>
          <tr valign="top">
            <td class="c43" width="6%" nowrap="nowrap">year</td>
            <td valign="bottom">An optional year for the ordinal day. If not present the current year is assumed.</td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c44" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Integer array holding a "DAT" array,
                similar in structure to the array returned by the intrinsic
                <b>DATE_AND_TIME</b>(3f):
                <pre> dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
                The timezone value is from the current time on the current platform.
            </td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_o2d
    use M_time, only : o2d,fmtdate
    implicit none
    integer :: year
       do year=2004,2008
          write(*,*)'100th day of ',year,' is ',fmtdate(o2d(100,year))
       enddo
       write(*,*)'100th day of this year is ',fmtdate(o2d(100))
    end program demo_o2d
<br />
</pre>results:
        <pre>
    100th day of 2004 is Friday, April 9th, 2004 00:00:00 PM UTC-02:40
    100th day of 2005 is Sunday, April 10th, 2005 00:00:00 PM UTC-02:40
    100th day of 2006 is Monday, April 10th, 2006 00:00:00 PM UTC-02:40
    100th day of 2007 is Tuesday, April 10th, 2007 00:00:00 PM UTC-02:40
    100th day of 2008 is Wednesday, April 9th, 2008 00:00:00 PM UTC-02:40
    100th day of this year is Saturday, April 9th, 2016 00:00:00 PM UTC-02:40
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c45">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>ordinal_seconds(3f)</b> - [M_time] seconds since beginning of year <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <a name="6"></a>
      <h3><a name="6">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>ordinal_seconds</b>()
<br />    integer :: ordinal_seconds
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Return number of seconds since beginning of current year.
        <p>Before using this routine consider the consequences if the application is running at the moment a new year begins.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLE</a></h3>
      <blockquote>
        sample program
        <pre>
   program demo_ordinal_seconds
   use M_time, only : ordinal_seconds
   implicit none
   character(len=1) :: paws
   integer          :: ios
   integer          :: istart, iend
   istart=ordinal_seconds()
   write(*,'(a)',advance='no')'now pause. Enter return to continue ...'
   read(*,'(a)',iostat=ios) paws
   iend=ordinal_seconds()
   write(*,*)'that took ',iend-istart,'seconds'
   write(*,*)istart,iend
   end program demo_ordinal_seconds
</pre>
      </blockquote><a name="4"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c46">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>ordinal_to_date(3f)</b> - [M_time] when given a valid year and day of the year returns the DAT array for the date <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="6"></a>
      <h3><a name="6">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>ordinal_to_date</b>(<i>yyyy</i>, <i>ddd</i>, <i>dat</i>)
<br />      integer, intent(in)   :: yyyy
      integer, intent(in)   :: ddd
      integer, intent(out)  :: dat
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        When given a valid year, YYYY, and day of the year, DDD, returns the date as a DAT date array
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">

          <tr valign="top">
            <td class="c47" width="6%" nowrap="nowrap">yyyy</td>
            <td valign="bottom">known year</td>
          </tr>

          <tr valign="top">
            <td class="c47" width="6%" nowrap="nowrap">ddd</td>
            <td valign="bottom">known ordinal day of the year</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c47" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">DAT array describing the date</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
   program demo_ordinal_to_date
   use M_time, only : ordinal_to_date
   implicit none
   INTEGER            :: yyyy, ddd, mm, dd
   integer            :: dat(8)
   integer            :: ios
     INFINITE: do
        write(*,'(a)',advance='no')'Enter year YYYY and ordinal day of year DD '
        read(*,*,iostat=ios)yyyy,ddd
        if(ios.ne.0)exit INFINITE
        ! recover month and day from year and day number.
        call ordinal_to_date(yyyy, ddd, dat)
        mm=dat(2)
        dd=dat(3)
        write(*,*)'MONTH=',mm,' DAY=',dd
      enddo INFINITE
   end program demo_ordinal_to_date
</pre>
      </blockquote>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c48">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>phase_of_moon(3f)</b> - [M_time] return name for phase of moon for given date <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <a name="6"></a>
      <h3><a name="6">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>phase_of_moon</b>(<i>datin</i>)
<br />   integer,intent(in)            :: datin(8)
   character(len=:),allocatable  :: phase_of_moon
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Phases Of The Moon
        <p>This procedure is used to support the %p field descriptor for the <b>fmtdate</b>(3f) routine.</p>
        <p>The moon circles the earth every 29.530588853 days on average, so pick a starting point and count. A new moon occurred at Julian date 2451550.1
        (January 6, 2000, 18:14 UTC). Then it is easy to count the number of days since the last new moon. This is an approximate calculation.</p>
        <p>There are eight generally recognized phases of the moon in common use</p>
        <blockquote>
          <ul>
              <li>new or dark</li>
              <li>waxing crescent</li>
              <li>first quarter</li>
              <li>waxing gibbous</li>
              <li>full</li>
              <li>waning gibbous</li>
              <li>laster quarter</li>
              <li>waning crescent</li>
          </ul>
        </blockquote>
        <p>To calculate the phase of the moon simply divide the days since the last new moon by eight and select the appropriate phase.</p>
        <p>Note that technically the four states (new, first quarter, full, third quarter) are events not phases. That is to say, the moon is technically
        only new for an instant.</p>
      </blockquote><a name="3"></a>
      <h3><a name="3">EXAMPLES</a></h3>
      <blockquote>
        Sample:
        <pre>
   program demo_phase_of_moon
   use M_time, only : now
   use M_time, only : phase_of_moon
   use M_time, only : moon_fullness
   implicit none
   integer             :: dat(8)
      ! generate DAT array
      call date_and_time(values=dat)
      ! show DAT array
      write(*,'(" Today is:",*(i0:,":"))')dat
      ! the %p and %P fields are supported by fmtdate(3f)
      write(*,*)now('The phase of the moon is %p, with a fullness of %P')
      write(*,'(1x,*(a))',advance='no')'The phase of the moon is ',trim( phase_of_moon(dat)),','
      write(*,'(1x,a,i0,a)')'with a fullness of ', moon_fullness(dat),'%'
   end program demo_phase_of_moon
<br />
</pre>Sample output:
        <pre>
    Today is:2018:11:3:-240:20:18:44:245
    The phase of the moon is Waning crescent, with a fullness of -30%
    The phase of the moon is Waning crescent, with a fullness of -30%
<br />
</pre>
      </blockquote><a name="4"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c49">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>sec2days(3f)</b> - [M_time] convert seconds to string of form dd-hh:mm:ss <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>sec2days</b>(seconds,crop) <b>result</b>(<i>dhms</i>)
<br />    real(kind=realtime),intent(in) :: seconds
      or
    integer,intent(in)             :: seconds
      or
    real,intent(in)                :: seconds
      or
    character(len=*)               :: seconds
<br />    logical,intent(in),optional    :: crop
    character(len=:),allocatable   :: dhms
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Given a number of seconds convert it to a string of the form
        <pre>
      dd-hh:mm:ss
<br />
</pre>where dd is days, hh hours, mm minutes and ss seconds.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c50" colspan="1" width="%6">seconds</td>
            <td>
              number of seconds to convert to string of form
              dd-hh:mm:ss. May be of type INTEGER, REAL,
              <b>REAL</b>(KIND=REALTIME), or CHARACTER.
              <p>CHARACTER strings may be of the form
              NNdNNhNNmNNs. Case,spaces and underscores are
              ignored. Allowed aliases for d,h,m, and s units are</p>
              <pre>
                  d -  days,day
                  m -  minutes,minute,min
                  h -  hours,hour,hrs,hr
                  s -  seconds,second,sec
              </pre>
              The numeric values may represent floating point numbers.
            </td>
          </tr>
          <tr valign="top">
            <td class="c50" width="6%" nowrap="nowrap">crop</td>
            <td valign="bottom">if .true., remove leading zero day values
                or day and hour values. Optional, defaults to .false. .
            </td>
          </tr>
        </table>
      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c50" width="6%" nowrap="nowrap">dmhs</td>
            <td valign="bottom">the returned string of form [d:h:]m:s</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample Program:
        <pre>
    program demo_sec2days
    use M_time, only : sec2days
    implicit none
       write(*,*)sec2days(129860)
       write(*,*)sec2days(80000.0d0)
       write(*,*)sec2days(80000.0,crop=.true.)
       write(*,*)sec2days('1 day 2.0hr 100 min 300.0seconds')
    end program demo_sec2days
<br />
</pre>results:
        <pre>
    1-12:04:20
    0-22:13:20
    22:13:20
    1-03:45:00
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c51">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>u2d(3f)</b> - [M_time] given Unix Epoch Time returns DAT date-time array <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>u2d</b>(<i>unixtime</i>) result (<i>dat</i>)
<br />    class(*),intent(in),optional      :: unixtime
    ! integer
    ! real
    ! real(kind=realtime)
<br />    integer                           :: dat(8)
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c52" colspan="1" width="%6">unixtime</td>
            <td>The "Unix Epoch" time, or the number of seconds since
            00:00:00 on January 1st, 1970, UTC. If not present, use
            current time.</td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c52" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">Integer array holding a "DAT" array, similar in structure to the array returned by the intrinsic
                <b>DATE_AND_TIME</b>(3f):
                <pre> dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
            </td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_u2d
    use M_time, only : u2d, d2u, fmtdate, realtime
    implicit none
    real(kind=realtime) :: today
    integer :: dat(8)
       call date_and_time(values=dat) ! get the date using intrinsic
       today=d2u(dat)                 ! convert today to Julian Date
       write(*,*)'Today=',fmtdate(u2d(today))
       write(*,*)'Yesterday=',fmtdate(u2d(today-86400.0d0)) ! subtract day
       write(*,*)'Tomorrow=',fmtdate(u2d(today+86400.0d0))  ! add day
    end program demo_u2d
<br />
</pre>results:
        <pre>
    Today=Tuesday, July 19th, 2016 11:10:08 AM
    Yesterday=Monday, July 18th, 2016 11:10:08 AM
    Tomorrow=Wednesday, July 20th, 2016 11:10:08 AM
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c53">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>unix_to_date(3f)</b> - [M_time] converts Unix Epoch Time to DAT date-time array <b>(LICENSE:PD)</b>
      </blockquote>
      <a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
        <pre>
subroutine <b>unix_to_date</b>(unixtime,dat,ierr)
<br />    real(kind=realtime),intent(in) :: unixtime ! Unix time (seconds)
    integer,intent(out)            :: dat(8)   ! date and time array
    integer,intent(out)            :: ierr     ! 0 for successful execution
<br />
</pre>
      <a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      
        Converts a Unix Epoch Time (UET) to a DAT date-time array.
      <a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      
        <table cellpadding="3">
          <tr valign="top">
            <td class="c54" colspan="1" width="%6">unixtime
            </td>
            <td>The "Unix Epoch" time, or the number of seconds
                since 00:00:00 on January 1st, 1970, UTC; of type
                <b>real</b>(kind=realtime).
            </td>
          </tr>
        </table>

      <a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      
        <table cellpadding="3">

          <tr valign="top">
            <td class="c54" width="6%" nowrap="nowrap">dat
            </td>
            <td valign="bottom">Integer array holding a "DAT" array,
                similar in structure to the array returned by the intrinsic
                <b>DATE_AND_TIME</b>(3f):
                <pre> dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds] </pre>
            </td>
          </tr>
        </table>
     
      <table cellpadding="3">
        <tr valign="top">
          <td class="c54" width="6%" nowrap="nowrap">ierr</td>
          <td valign="bottom">Error code. If 0 no error occurred.</td>
        </tr>
      </table>

      <a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_unix_to_date
    use M_time, only : unix_to_date, u2d, fmtdate, realtime
    implicit none
    real(kind=realtime)           :: unixtime
    real(kind=realtime),parameter :: DAY=86400.0d0 ! seconds in a day
    integer                       :: dat(8)
    integer                       :: ierr
       unixtime=1468939038.4639933d0            ! sample Unix Epoch time
       call unix_to_date(unixtime,dat,ierr)     ! create DAT array for today
       write(*,*)'Sample Date=',fmtdate(dat)
       call unix_to_date(unixtime-DAY,dat,ierr) ! go back one day
       write(*,*)'Day Before =',fmtdate(dat)    ! subtract day and print
       call unix_to_date(unixtime+DAY,dat,ierr) ! go forward one day
       write(*,*)'Day After  =',fmtdate(dat)    ! add day print
    end program demo_unix_to_date
<br />
</pre>results:
        <pre>
    Sample Date=Tuesday, July 19th, 2016 10:37:18 AM
    Day Before =Monday, July 18th, 2016 10:37:18 AM
    Day After  =Wednesday, July 20th, 2016 10:37:18 AM
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c55">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
        <b>v2mo(3f)</b> - [M_time] returns the month name of a Common month number <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="8"></a>
      <h3><a name="8">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
function <b>v2mo</b>(<i>imonth</i>) <b>result</b>(<i>month_name</i>)
<br />    integer,intent(in)           :: imonth      ! month number (1-12)
    character(len=:),allocatable :: month_name  ! month name
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Given a Common Calendar month number, return the name of the month as a string.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c56" width="6%" nowrap="nowrap">imonth</td>
            <td valign="bottom">Common month number (1-12). If out
                of the allowable range the month name returned will be
                'UNKNOWN'.
            </td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c56" colspan="1" width="%6">month_name</td>
            <td>A string representing a month name or the word 'UNKNOWN'</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        Sample program:
        <pre>
    program demo_v2mo
    use M_time, only : v2mo
    implicit none
    integer :: i
       do i=1,13
          write(*,*)v2mo(i)
       enddo
    end program demo_v2mo
<br />
</pre>results:
        <pre>
    January
    February
    March
    April
    May
    June
    July
    August
    September
    October
    November
    December
    UNKNOWN.
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <a name="top" id="top"></a>
  <div id="Container">
    <div id="Content">
      <div class="c57">
      </div><a name="0"></a>
      <h3><a name="0">NAME</a></h3>
      <blockquote>
       <b>w2d(3f)</b> - [M_time] calculate DAT date-time array from iso-8601 Week-numbering year date yyyy-Www-d <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>
      <a name="12"></a>
      <h3><a name="12">SYNOPSIS</a></h3>
      <blockquote>
        <pre>
subroutine <b>w2d</b>(iso_year,iso_week,iso_weekday,dat)
<br />    integer,intent(in)      :: iso_year, iso_week, iso_weekday
    integer,intent(out)     :: dat(8)     ! output date array
<br />
</pre>
      </blockquote><a name="2"></a>
      <h3><a name="2">DESCRIPTION</a></h3>
      <blockquote>
        Given an ISO-8601 week return a "DAT" array defining a date and time, The ISO-8601 is supplied as three integer values defining the ISO year, week
        of year and weekday.
      </blockquote><a name="3"></a>
      <h3><a name="3">OPTIONS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c58" colspan="1" width="%6">iso_year</td>
            <td>ISO-8601 year number for the given date</td>
          </tr>
          <tr valign="top">
            <td class="c58" colspan="1" width="%6">iso_week</td>
            <td>ISO-8601 week number for the given date</td>
          </tr>
          <tr valign="top">
            <td class="c58" colspan="1" width="%6">iso_weekday</td>
            <td>ISO-8601 weekday number for the given date</td>
          </tr>
          <tr valign="top">
            <td class="c58" colspan="1" width="%6">iso_name</td>
            <td>ISO-8601 Week string for the data in the form "yyyy-Www-d".</td>
          </tr>
        </table>

      </blockquote><a name="4"></a>
      <h3><a name="4">RETURNS</a></h3>
      <blockquote>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c58" width="6%" nowrap="nowrap">dat</td>
            <td valign="bottom">"DAT" array (an integer array of the same format as the array returned by the intrinsic <b>DATE_AND_TIME</b>(3f)) describing
            the date to be used, which is the basic time description used by the other <b>M_time</b>(3fm) module procedures.</td>
          </tr>
        </table>

      </blockquote><a name="5"></a>
      <h3><a name="5">EXAMPLE</a></h3>
      <blockquote>
        <p>Sample program:</p>
        <pre>
    program demo_w2d
    use M_time, only : w2d, fmtdate
    implicit none
       write(*,'(a)')'Given Monday 29 December 2008 is written "2009-W01-1"'
       call printit(2009,1,1)
       write(*,'(a)')'Given Sunday 3 January 2010 is written "2009-W53-7"'
       call printit(2009,53,7)
       write(*,'(a)')'Given the Gregorian date Sun 31 December 2006 is written 2006-W52-7'
       call printit(2006,52,7)
       write(*,'(a)')'Given 27 September 2008 is 2008-W39-6'
       call printit(2008,39,6)
    contains
    subroutine printit(iso_year,iso_week,iso_weekday)
    integer  :: iso_year, iso_week, iso_weekday ! ISO-8601 Week:   2016-W29-1
    integer  :: dat(8)                          ! input date array
       call w2d(iso_year,iso_week,iso_weekday,dat)
       write(*,'(a,i0)')'GIVEN:           '
       write(*,'(a,i0)')'ISO-8601 year    ',iso_year
       write(*,'(a,i0)')'ISO-8601 week    ',iso_week
       write(*,'(a,i0)')'ISO-8601 weekday ',iso_weekday
       write(*,'(a,i0)')'RESULT:          '
       write(*,'(a,*(i0:,","))')'   DAT array        ',dat
       write(*,'(a,/,77("="))')'    '//fmtdate(dat,'long')
    end subroutine printit
    end program demo_w2d
<br />
</pre>Results:
        <pre>
    Given Monday 29 December 2008 is written "2009-W01-1"
    GIVEN:
    ISO-8601 year    2009
    ISO-8601 week    1
    ISO-8601 weekday 1
    RESULT:
       DAT array        2008,12,29,-240,0,0,0,0
        Monday, December 29th, 2008 12:00:00 AM UTC-04:00
    =============================================================================
    Given Sunday 3 January 2010 is written "2009-W53-7"
    GIVEN:
    ISO-8601 year    2009
    ISO-8601 week    53
    ISO-8601 weekday 7
    RESULT:
       DAT array        2010,1,3,-240,0,0,0,0
        Sunday, January 3rd, 2010 12:00:00 AM UTC-04:00
    =============================================================================
    Given the Gregorian date Sun 31 December 2006 is written 2006-W52-7
    GIVEN:
    ISO-8601 year    2006
    ISO-8601 week    52
    ISO-8601 weekday 7
    RESULT:
       DAT array        2006,12,31,-240,0,0,0,0
        Sunday, December 31st, 2006 12:00:00 AM UTC-04:00
    =============================================================================
    Given 27 September 2008 is 2008-W39-6
    GIVEN:
    ISO-8601 year    2008
    ISO-8601 week    39
    ISO-8601 weekday 6
    RESULT:
       DAT array        2008,9,27,-240,0,0,0,0
        Saturday, September 27th, 2008 12:00:00 AM UTC-04:00
    =============================================================================
<br />
</pre>
      </blockquote><a name="6"></a>
      <h3><a name="6">DEFINITION</a></h3>
      <blockquote>
        The ISO-8601 date and time standard was issued by the International Organization for Standardization (ISO). It is used (mainly) in government and
        business for fiscal years, as well as in timekeeping. The system specifies a week year atop the Gregorian calendar by defining a notation for
        ordinal weeks of the year.
        <p>An ISO week-numbering year (also called ISO year informally) has 52 or 53 full weeks. That is 364 or 371 days instead of the usual 365 or 366
        days. The extra week is referred to here as a leap week, although ISO-8601 does not use this term. Weeks start with Monday. The first week of a year
        is the week that contains the first Thursday of the year (and, hence, always contains 4 January). ISO week year numbering therefore slightly
        deviates from the Gregorian for some days close to January 1st.</p>
      </blockquote><a name="7"></a>
      <h3><a name="7">METHOD</a></h3>
      <blockquote>
        Calculating a date given the year, week number and weekday
        <p>This method requires that one know the weekday of 4 January of the year in question. Add 3 to the number of this weekday, giving a correction to
        be used for dates within this year.</p>
        <p>Method: Multiply the week number by 7, then add the weekday. From this sum subtract the correction for the year. The result is the ordinal date,
        which can be converted into a calendar date. If the ordinal date thus obtained is zero or negative, the date belongs to the previous calendar year;
        if greater than the number of days in the year, to the following year.</p>
        <p>Example: year 2008, week 39, Saturday (day 6) Correction for 2008: 5 + 3 = 8 (39 x 7) + 6 = 279 279 - 8 = 271 Ordinal day 271 of a leap year is
        day 271 - 244 = 27 September Result: 27 September 2008</p>
      </blockquote><a name="8"></a>
      <h3><a name="8">ISO_NAME</a></h3>
      <blockquote>
        Week date representations are in the format YYYYWww-D.

        <table cellpadding="3">
          <!-- tsb: Week date representations are in the format YYYYWww-D.
 -->
          <tr valign="top">
            <td width="3%">YYY</td>
            <td> indicates the ISO week-numbering year which is slightly different from the traditional Gregorian calendar year.</td>
          </tr>
          <tr valign="top">
            <td width="3%">Www</td>
            <td>is the week number prefixed by the letter W, from W01 through W53.</td>
          </tr>
          <tr valign="top">
            <td width="3%">D</td>
            <td> is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.</td>
          </tr>
        </table>
      </blockquote>
      <p>For example, the Gregorian date 31 December 2006 corresponds to the Sunday of the 52nd week of 2006, and is written</p>
      <pre>
    2006-W52-7 (extended form)
    or
    2006W527 (compact form).
<br />
</pre><a name="9"></a>
      <h3><a name="9">REFERENCE</a></h3>
      <blockquote>
        From Wikipedia, the free encyclopedia 2016-08-08
      </blockquote><a name="10"></a>
    </div>
  </div>
</div>
</article>
</body>
</html>

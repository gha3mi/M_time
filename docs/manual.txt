b2d (3m_time)	     - [M_time:BAS] given a BAS (Baseday and Seconds) returns a date-time array DAT. (LICENSE:MIT)
bas_to_date (3m_time) - [M_time:BAS] converts a BAS(Baseday and Seconds) to a DAT date-time array. (LICENSE:MIT)
box_month (3m_time)  - [M_time:DATE_PRINTING] create specified month in a character array (LICENSE:MIT)
d2b (3m_time)	     - [M_time:BAS] given DAT date-time array returns Baseday and Seconds type (LICENSE:MIT)
d2j (3m_time)	     - [M_time:JULIAN] given DAT date-time array returns Julian Date (LICENSE:MIT)
d2m (3m_time)	     - [M_time:MODIFIED_JULIAN] given DAT date-time array returns Modified Julian Date (LICENSE:MIT)
d2o (3m_time)	     - [M_time:ORDINAL_DAY] converts DAT date-time array to Ordinal day (LICENSE:MIT)
d2u (3m_time)	     - [M_time:UNIX_EPOCH] given DAT date-time array returns Unix Epoch Time (UET starts at 0000 on 1 Jan. 1970, UTC) (LICENSE:MIT)
d2w (3m_time)	     - [M_time:WEEK_OF_YEAR] calculate iso-8601 Week, both numerically and as a string of the form "yyyy-Wmm-d" given a DAT date-time array (LICENSE:MIT)
date_to_bas (3m_time) - [M_time:BAS] converts DAT date-time array to Baseday and Seconds (LICENSE:MIT)
date_to_julian (3m_time) - [M_time:JULIAN] converts DAT date-time array to Julian Date (LICENSE:MIT)
date_to_modified_julian (3m_time) - [M_time:MODIFIED_JULIAN] converts DAT date-time array to Modified Julian Date (LICENSE:MIT)
date_to_unix (3m_time) - [M_time:UNIX_EPOCH] converts DAT date-time array to Unix Epoch Time (LICENSE:MIT)
days2sec (1)	     - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds (LICENSE:PD)
days2sec (3m_time)   - [M_time:DURATION] convert string of form [[-]dd-]hh:mm:ss.nn or dNNhNNmNNsNN to seconds (LICENSE:MIT)
dow (3m_time)	     - [M_time:DAY_OF_WEEK] given a date-time array DAT return the day of the week (LICENSE:MIT)
easter (3m_time)     - [M_time:ASTROLOGICAL] calculate date for Easter given a year (LICENSE:MIT)
fmtdate (3m_time)    - [M_time:DATE_PRINTING] given DAT date-time array return date as string using specified format (LICENSE:MIT)
fmtdate_usage (3m_time) - [M_time:DATE_PRINTING] display macros recognized by fmtdate(3f) and now(3f) (LICENSE:MIT)
guessdate (3m_time)  - [M_time:READING_DATES] reads in a date, in various formats (LICENSE:MIT)
howlong (1)	     - display wallclock time taken to execute a system command
j2d (3m_time)	     - [M_time:JULIAN] given a JD (Julian Date) returns a date-time array DAT. (LICENSE:MIT)
julian_to_date (3m_time) - [M_time:JULIAN] converts a JD(Julian Date) to a DAT date-time array. (LICENSE:MIT)
locale (3m_time)     - [M_time:DATE_PRINTING] allow for selecting languages to represent month and weekday names (LICENSE:MIT)
m2d (3m_time)	     - [M_time:MODIFIED_JULIAN] given a MJD (Modified Julian Date) returns a date-time array DAT. (LICENSE:MIT)
M_time (3m_time)     - [M_time::INTRO] Fortran module for manipulating and presenting time and date values as defined in ISO 8601:1988 (LICENSE:MIT)
M_time__oop (3m_time) - [M_time::INTRO::OOPS] OOP interface for M_time(3fm) (LICENSE:MIT)
mo2d (3m_time)	     - [M_time:MONTH_NAME] given month name return DAT date-time array for beginning of that month in specified year (LICENSE:MIT)
mo2v (3m_time)	     - [M_time:MONTH_NAME] given month name return month number (1-12) of that month (LICENSE:MIT)
modified_julian_to_date (3m_time) - [M_time:MODIFIED_JULIAN] converts a MJD(Modified Julian Date) to a DAT date-time array. (LICENSE:MIT)
month (1)	     - [TIME] display a calendar (LICENSE:PD)
moon_fullness (3m_time) - [M_time:ASTROLOGICAL] return percentage of moon phase from new to full (LICENSE:MIT)
now (3m_time)	     - [M_time:DATE_PRINTING] return string representing current time given one of many formats to present with (LICENSE:MIT)
o2d (3m_time)	     - [M_time:ORDINAL_DAY] converts Ordinal day to DAT date-time array (LICENSE:MIT)
ordinal_seconds (3m_time) - [M_time:ORDINAL_DAY] seconds since beginning of year (LICENSE:MIT)
ordinal_to_date (3m_time) - [M_time:ORDINAL_DAY] when given a valid year and day of the year returns the DAT array for the date (LICENSE:MIT)
paws (1)	     - [TIME] pause until specified time or for specified duration (LICENSE:PD)
phase_of_moon (3m_time) - [M_time:ASTROLOGICAL] return name for phase of moon for given date (LICENSE:MIT)
sec2days (1)	     - [TIME] Convert durations of time to string of form dd-hh:mm:ss (LICENSE:PD)
sec2days (3m_time)   - [M_time:DURATION] convert seconds to string of form dd-hh:mm:ss (LICENSE:MIT)
system_sleep (3m_time) - [M_time:C_INTERFACE] call C sleep(3c) or usleep(3c) procedure (LICENSE:MIT)
today (1)	     - [TIME] output current time for uses such as file suffixes. (LICENSE:PD)
u2d (3m_time)	     - [M_time:UNIX_EPOCH] given Unix Epoch Time returns DAT date-time array (LICENSE:MIT)
unix_to_date (3m_time) - [M_time:UNIX_EPOCH] converts Unix Epoch Time to DAT date-time array (LICENSE:MIT)
v2mo (3m_time)	     - [M_time:MONTH_NAME] returns the month name of a Common month number (LICENSE:MIT)
w2d (3m_time)	     - [M_time:WEEK_OF_YEAR] calculate DAT date-time array from iso-8601 numeric Week values or from string "yyyy-Www-d" (LICENSE:MIT)
howlong.1.man(1m_time)					howlong.1.man(1m_time)

	      help_text=[ CHARACTER(LEN=128) :: &

NAME
  howlong(1) - display wallclock time taken to execute a system command

SYNOPIS
  howlong SYSTEM_COMMAND

     or

  howlong --help|--version

DESCRIPTION
  Perhaps the simplest performance metric is to just measure the wallclock
  time taken by a program. This could literally be measured using a
  conventional clock or stopwatch. This is difficult to automate!  So
  typically a command like the GNU/Linux or Unix command time(1) is used.

  Commands such as time(1) often provide more than wallclock times too. But
  lets construct a wallclock timing tool of our own using standard Fortran
  (not even the ISO_C_Binding interface will be called upon) that will measure
  the run time of a command.

  Once passed a command to time on the command line, it will then run the
  command and report the wallclock time use by the program, and echo the
  command.

  Next we provide a simple program that calls the routine(s) of interest
  enough times to get useful timing information and time it.

  So lets say we compiled up the test program using two different sets of
  compiler options:

      f90 little_test.f90 -O0 -o little_test0
      f90 little_test.f90 -O3 -o little_test3

  Now to run the programs via our timing utility only takes a few commands:

      howlong ./little_test0
      Wallclock: 0-00:00:25.461 :command: ./little_test0
      howlong ./little_test3
      Wallclock: 0-00:00:10.274 :command: ./little_test3

SAMPLE SUBJECT PROGRAM
  An uninstrumented test program for timing :

     program little_test
     use,intrinsic :: iso_fortran_env, only : int8
     implicit none
     character(len=*),parameter 	    :: original = "abcdxyz ZXYDCBA _!@"
     integer,parameter			    :: how_many_times = 100000000
     character(len=:),volatile,allocatable  :: t
     integer				    :: i
	do i=1,how_many_times
	  t=upper(original)
	  t=lower(original)
	enddo
     contains
     function upper(str) result(translated)
     integer(kind=int8), parameter :: &
     & ascii_diff = abs(iachar('A',kind=int8) - iachar('a',kind=int8))
     character(*), intent(in) :: str
     integer :: i
     character(len=len(str)) :: translated

	translated=str
	do i = 1, len(str)
	  select case(str(i:i))
	    case("a":"z")
	      translated(i:i) = achar(iachar(str(i:i))-ascii_diff)
	  end select
	enddo
     end function upper

     function lower(str) result(translated)
     integer(kind=int8), parameter :: &
     & ascii_diff = abs(iachar('A',kind=int8) - iachar('a',kind=int8))
     character(*), intent(in) :: str
     integer :: i
     character(len=len(str)) :: translated

	translated=str
	do i = 1, len(str)
	  select case(str(i:i))
	    case("A":"Z")
	      translated(i:i) = achar(iachar(str(i:i))+ascii_diff)
	  end select
	enddo
     end function lower

     end program little_test

FOOTNOTES
  Note that in many HPC environments programs are often run via a job
  scheduler like Slurm, LSF, PBS, Torque, ... . In these environments there
  are usually account records of each job that provide resource usage
  statistics.

OPTIONS
  --help
    display this help and exit

  --version
    output version information and exit

EXAMPLES
  howlong ./myprogram

SEE ALSO
  gprof(1), gcov(1)

			       January 26, 2025 	howlong.1.man(1m_time)
paws.1.man(1m_time)					   paws.1.man(1m_time)

NAME
  paws(1f) - [TIME] pause until specified time or for specified duration
  (LICENSE:PD)

SYNOPSIS
  paws [dd-hh:mm:ss[.xxx]|xxx.yyy[s|m|h|d]][ -msg message][ -cmd command][
  -repeat TIMES[ -fmt ]]|...  [ -uet|-jd|-dat|[ -date|-until]] paws
  --version|--help

DESCRIPTION
  Given a duration in the form dd-hh:mm:ss.xxx where dd is days, hh hours, mm
  minutes and ss.xxx seconds convert it to seconds. Then, pause for that many
  seconds. Alternatively, pause until specified date has passed.  If no
  duration is specified wait until a carriage return is entered.

OPTIONS
  dd-hh:mm:ss
    Given a string representing a duration of time in the following forms:

		     dd-hh:mm:ss[.xx]
			hh:mm:ss[.xx]
			   mm:ss[.xx]
			      ss[.xx]
			or
		     xx[.yy]SUFFIX

  convert it to seconds and pause for that amount of time.  Suffix may be s
  for seconds, m for minutes, h for hours, or d for days.

  -date|-until
    wait until the specified date has passed (before starting optional pause).
    See guessdate(3f) for syntax allowed for the date.

  -uet
    wait until the specified Unix Epoch Time has passed

  -jd
    wait until the specified Julian Date has passed

  -dat
    wait until the specified date vector has passed (year month day timezone
    hour minutes seconds milliseconds)

  -repeat NNN
    The duration is repeated NNN times with the date displayed at the end of
    each pause.

  --msg
    message to display before pausing

  --cmd
    command to execute after a pause

  --fmt
    date format (see fmtdate(3f) for details)

  --help
    display this help and exit

  --version
    output version information and exit

  For more information on the format of the dates, see the now(1) command.

EXAMPLES
  Typical usage:

    paws 2:00:00	      # pause for two hours
    paws 3600		      # pause one hour
    paws 0.10		      # pause one tenth of a second
    paws 1 -repeat 60	      # pause sixty seconds, displaying date each second
    paws -until 23:59:59      # pause until midnight
    paws 15:00 -date 23:59:59 # wait till midnight then an additional 15 minutes

AUTHOR
  John S. Urban

LICENSE
  Public Domain

			       January 26, 2025 	   paws.1.man(1m_time)
sec2days.1.man(1m_time) 			       sec2days.1.man(1m_time)

NAME
  sec2days(1f) - [TIME] Convert durations of time to string of form dd-
  hh:mm:ss (LICENSE:PD)

SYNOPSIS
  sec2days nnnn[.xxx] [ -crop]| --version| --help

DESCRIPTION
  Given a numeric string representing seconds or labeled units of time convert
  it to a string of the form

	dd-hh:mm:ss

  where dd is days, hh hours, mm minutes and ss seconds.

OPTIONS
  nnnn[.xxx]
    Defaults to number of seconds to convert to string of

    form dd-hh:mm:ss.
      nnnn may be interspersed with unit codes d,h,m,s. Spaces, commas and
      case are ignored. Allowed aliases for the unit codes are

		     d	days and day
		     h	hours,hour,hrs, and hr
		     m	minutes,minute and min
		     s	seconds,second and sec

  -crop
    trim leading zero values from output

  -radix
    character used as decimal separator

  --help
    display this help and exit

  --version
    output version information and exit

EXAMPLES
  usage

     sec2days 129860
     1-12:04:20
     sec2days 1d2h3m4s
     1-02:03:04
     sec2days 1.0 days 2 hours 3 minutes 4 seconds
     1-02:03:04
     sec2days 1.5d
     1-12:00:00

AUTHOR
  John S. Urban

LICENSE
  Public Domain

			       January 26, 2025        sec2days.1.man(1m_time)
today.1.man(1m_time)					  today.1.man(1m_time)

NAME
  today(1f) - [TIME] output current time for uses such as file suffixes.
  (LICENSE:PD)

SYNOPSIS
  today format|--help|--version|--test

DESCRIPTION
  Outputs the current date using the specified format. Typically used to
  generate a string to be used in building filenames containing date
  information.

OPTIONS
  format
    any allowable format for the fmtdate(3) routine.  defaults to "Y-M-D".

  --help
    display this help and exit

  --version
    output version information and exit

  --test
    display allowed options for building a format

EXAMPLES
  Sample commands:

	  $today
	  2024-05-27

	  $mv -v myfile myfile.`today`
	  renamed 'myfile' -> 'myfile.2024-05-27'

	  $find . -ls > MANIFEST.`today epoch`; ls MANIFEST.*
	  MANIFEST.1716840303

	  $mkdir `today YMDhms`
	  20240527160333

	  $today yearmonthdayhourminutesecond
	  20240527160442

	  $today --test 			 # show formatting options

AUTHOR
  John S. Urban

LICENSE
  Public Domain

			       January 26, 2025 	  today.1.man(1m_time)
month.1.man(1m_time)					  month.1.man(1m_time)

NAME
  month(1f) - [TIME] display a calendar (LICENSE:PD)

SYNOPSIS
  month [[ -year] NNNN] [ -month NN|month_name]

DESCRIPTION
  month(1) displays a simple calendar. If no arguments are specified, the
  current year is displayed.

OPTIONS
  -month NN
    Display single month output. The month is numeric (1-12) or a month name
    or blank. If blank the current month is assumed.

  -year NNNN
    Select the year to display. A year starts on Jan 1st.

  -help
    Display help text and exit.

  -version
    Display version information and exit.

EXAMPLES
  month -month 12

	 >    December 2015
	 >Mo Tu We Th Fr Sa Su
	 >    1  2  3  4  5  6
	 > 7  8  9 10 11 12 13
	 >14 15 16 17 18 19 20
	 >21 22 23 24 25 26 27
	 >28 29 30 31

  month -month April # month names may be given instead of numbers

AUTHOR
  John S. Urban

LICENSE
  Public Domain

			       January 26, 2025 	  month.1.man(1m_time)
days2sec.1.man(1m_time) 			       days2sec.1.man(1m_time)

NAME
  days2sec(1f) - [TIME] Convert [[-]dd-][[hh:]mm:]ss to seconds (LICENSE:PD)

SYNOPSIS
  Forms:

      days2sec dd-hh:mm:ss
      days2sec NNdNNhNNmNNs
      days2sec --version| --help

DESCRIPTION
  Given a duration in the form dd-hh:mm:ss where dd is days, hh hours, mm
  minutes and ss seconds convert it to seconds. Many utilities (ps(1), for
  example) show times in this format to make it more intelligible; but it
  generally easier to perform math on values represented in seconds.

OPTIONS
  dd-hh:mm:ss
    Given a string representing a duration of time in the following forms:

		    dd-hh:mm:ss
		       hh:mm:ss
			  mm:ss
			     ss

  convert it to seconds.

    The numeric values may represent floating point numbers.

    Spaces are ignored.

  NNdNNhNNmNNs
    Simple numeric values may also be used with unit suffixes; where s,m,h, or
    d represents seconds, minutes, hours or days and w represents weeks.
    Allowed aliases for w,d,h,m, and s units are

		     w -  weeks,week,wk,wks
		     d -  days,day
		     m -  minutes,minute,min
		     h -  hours,hour,hrs,hr
		     s -  seconds,second,sec,secs

  The numeric values may represent floating point numbers.

    Spaces, commas
      and case are ignored.

  --denominator
    divide the result by this value. Default is one(1).

  --help
    display this help and exit

  --version
    output version information and exit

EXAMPLES
  Usage

      days2sec 1-12:04:20
      129860
      days2sec 1.5 days
      129600
      days2sec 1.5 days 4hrs 30minutes
      145800
      days2sec 10s 10S 10s # DUPLICATES WITH UNITS ARE ALLOWED
      30
      days2sec 1 1 1  # SPACES ARE IGNORED
      111

SEE ALSO
  sec2days(1)

AUTHOR
  John S. Urban

LICENSE
  Public Domain

			       January 26, 2025        days2sec.1.man(1m_time)
bas_to_date(3m_time)					  bas_to_date(3m_time)

NAME
  bas_to_date(3f) - [M_time:BAS] converts a BAS(Baseday and Seconds) to a DAT
  date-time array.  (LICENSE:MIT)

SYNOPSIS
  subroutine bas_to_date(bas,dat,ierr)

      type(BAStime),intent(in) :: bas
      integer,intent(out)      :: dat(8)
      integer,intent(out)      :: ierr

DESCRIPTION
  Converts a Baseday and Seconds(BAS) value to a DAT date-time array.

  In this module the MJD date and time is stored internally as a structure
  named BAStime, containing the number of days since the beginning of the MJD
  Epoch and a double representing the seconds offset from the start of this
  day.

      type BAStime
       integer :: base_day ! number of days since the MJD Epoch date
       real(kind=real64) :: secs ! seconds from start of base_day
      end type BAStime

  A Modified Julian Date (MJD) measures days (and fractional days) since the
  start of 17 Nov 1858 CE in Universal Time (UTC).

  A Julian Date (JD) measures days (and fractional days) since noon on 1
  January, 4713 BCE in Universal Time (UTC).

  That is,

      Julian Date (MJD) = Julian Date (JD) - 2400000.5

  Using a structure allows for storing a date at a higher precision that other
  formats used by the library, although sometimes that lower precision is
  limited primarily by the definition (ie. the milliseconds in a DAT could be
  smaller units).

  MJD starts at midnight (00:00:00) so truncating the fractional component of
  MJD always gives the same Civil Calendar day whatever the time of day
  (unlike JD).

  The seconds offset may take any double-precision value, so that any
  date/time may be expressed in terms of an offset from the same MJD day. The
  seconds field thus may exceed a single day, and may also be negative.

OPTIONS
  bas
    A Baseday and Seconds (BAS) measures days since the start of 17 Nov 1858
    CE in Universal Time (UTC) and contains an offset value in seconds from
    that base date.

RETURNS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	       dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

  ierr
    Error code. If 0 no error occurred.

EXAMPLE
  Sample program:

       program demo_bas_to_date
       use M_time, only : bas_to_date, fmtdate, realtime, BAStime
       implicit none
       integer,parameter	  :: dp=kind(0.0d0)
       type(BAStime)		  :: bas, tomorrow, yesterday
       integer			  :: dat(8)
       integer			  :: ierr
       character(len=*),parameter :: g='(*(g0,1x))'
	  write(*,g)'bas_to_date:'
	  ! set sample Baseday and Seconds date
	  bas=BAStime( 60700, 0.213682349771_dp)
	  ! create DAT array for this date
	  call bas_to_date(bas,dat,ierr)
	  write(*,g)'Sample Date=',fmtdate(dat)
	  !
	  write(*,g)'add and subtract days from base_day:'
	  ! go back one day
	  yesterday= BAStime(bas%base_day-1,bas%secs)
	  call bas_to_date(yesterday,dat,ierr)
	  write(*,g)'Day Before =',fmtdate(dat)
	  !
	  ! go forward one day
	  tomorrow= BAStime(bas%base_day+1,bas%secs)
	  call bas_to_date(tomorrow,dat,ierr)
	  write(*,g)'Day After	=',fmtdate(dat)

	  write(*,g)'add and subtract seconds from BAS:'
	  ! go back one day
	  yesterday=bas-86400
	  call bas_to_date(yesterday,dat,ierr)
	  write(*,g)'Day Before =',fmtdate(dat)
	  !
	  ! go forward one day
	  yesterday=bas+86400
	  call bas_to_date(tomorrow,dat,ierr)
	  write(*,g)'Day After	=',fmtdate(dat)
	  !
       end program demo_bas_to_date

  Results:

      > bas_to_date:
      > Sample Date= Friday, January 24th, 2025 7:00:00 PM UTC-05:00
      > add and subtract days from base_day:
      > Day Before = Thursday, January 23rd, 2025 7:00:00 PM UTC-05:00
      > Day After  = Saturday, January 25th, 2025 7:00:00 PM UTC-05:00
      > add and subtract seconds from BAS:
      > Day Before = Thursday, January 23rd, 2025 7:00:00 PM UTC-05:00
      > Day After  = Saturday, January 25th, 2025 7:00:00 PM UTC-05:00

AUTHOR
  John S. Urban, 2025

LICENSE
   MIT
			       January 26, 2025 	  bas_to_date(3m_time)
d2b(3m_time)							  d2b(3m_time)

NAME
  d2b(3f) - [M_time:BAS] given DAT date-time array returns Baseday and Seconds
  type (LICENSE:MIT)

SYNOPSIS
  function d2b(dat) result(bas)

      integer,intent(in)  :: dat(8)
      type(BAStime) :: bas

DESCRIPTION
  Given DAT date-time array returns Baseday and Seconds type

OPTIONS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	       dat=[ year,month,day,timezone,hour,&
	       & minutes,seconds,milliseconds]

  If not present, use current time.

RETURNS
  bas
    A Baseday and seconds(MJD) is composed of whole days since the start of 17
    Nov 1858 CE in Universal Time (UTC) and an offset in seconds from the base
    day.

EXAMPLE
  Sample program:

      program demo_d2b
      use M_time, only : d2b, BAStime, d2j, d2m
      implicit none
      integer :: dat(8)
      type(BAStime) :: bas
      ! 			   Modified Julian Dates
      !
      !   To use this table, add the day-of-month to the tabulated entry.
      !   For example, 30 Jan 2000 = MJD 51573.
      ! __________________________________________________________________
      !  2000  2001  2002  2003  2004  2005  2006  2007  2008  2009
      integer,parameter :: array(1:12,2000:2009)=reshape([ &
       51543,51909,52274,52639,53004,53370,53735,54100,54465,54831, & ! Jan
       51574,51940,52305,52670,53035,53401,53766,54131,54496,54862, & ! Feb
       51603,51968,52333,52698,53064,53429,53794,54159,54525,54890, & ! Mar
       51634,51999,52364,52729,53095,53460,53825,54190,54556,54921, & ! Apr
       51664,52029,52394,52759,53125,53490,53855,54220,54586,54951, & ! May
       51695,52060,52425,52790,53156,53521,53886,54251,54617,54982, & ! Jun
       51725,52090,52455,52820,53186,53551,53916,54281,54647,55012, & ! Jul
       51756,52121,52486,52851,53217,53582,53947,54312,54678,55043, & ! Aug
       51787,52152,52517,52882,53248,53613,53978,54343,54709,55074, & ! Sep
       51817,52182,52547,52912,53278,53643,54008,54373,54739,55104, & ! Oct
       51848,52213,52578,52943,53309,53674,54039,54404,54770,55135, & ! Nov
       51878,52243,52608,52973,53339,53704,54069,54434,54800,55165],& ! Dec
       shape=shape(array),order=[2,1])
       integer :: i,j
	 call date_and_time(values=dat)
	 write(*,'(" Today is:",*(i0:,":"))')dat
	 write(*,*)'Baseday and Seconds is',d2b(dat)
	 do i=2000,2009
	  do j=1,12
	   !dat=[ year,month,day,timezone,hour,minutes,seconds,milliseconds]
	   dat=[i,j,1,0,0,0,0,0]
	   bas=d2b(dat)
	   if(array(j,i)+1.ne.bas%base_day)then
	      write(*,*)i,j,array(j,i)+1,d2b(dat),d2m(dat),d2j(dat)-2400000.5
	   endif
	  enddo
	 enddo
      end program demo_d2b

  Results:

      >  Today is:2025:1:26:-300:1:2:14:388
      >  Baseday and Seconds is 60701 21734.387965500355

AUTHOR
  John S. Urban, 2025

LICENSE
   MIT
			       January 26, 2025 		  d2b(3m_time)
d2j(3m_time)							  d2j(3m_time)

NAME
  d2j(3f) - [M_time:JULIAN] given DAT date-time array returns Julian Date
  (LICENSE:MIT)

SYNOPSIS
  function d2j(dat) result(julian)

      integer,intent(in)  :: dat(8)
      real(kind=realtime) :: julian

DESCRIPTION
  Given DAT date-time array returns Julian Date

OPTIONS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

  If not present, use current time.

RETURNS
  julian
    The Julian Date. Julian dates (abbreviated JD) are simply a continuous
    count of days and fractions since noon Universal Time on January 1, 4713
    BC (on the Julian calendar).

EXAMPLE
  Sample program:

      program demo_d2j
      use M_time, only : d2j
      implicit none
      integer :: dat(8)
	 call date_and_time(values=dat)
	 write(*,'(" Today is:",*(i0:,":"))')dat
	 write(*,*)'Julian Date is ',d2j(dat)
      end program demo_d2j

  results:

      Today is:2016:7:19:-240:2:11:50:885
      Julian Date is	2457588.7582278359

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		  d2j(3m_time)
d2w(3m_time)							  d2w(3m_time)

NAME
  d2w(3f) - [M_time:WEEK_OF_YEAR] calculate iso-8601 Week, both numerically
  and as a string of the form "yyyy-Wmm-d" given a DAT date-time array
  (LICENSE:MIT)

SYNOPSIS
  subroutine d2w(dat,iso_year,iso_week,iso_weekday,iso_name)

      integer,intent(in)	      :: dat(8)     ! input date array
      integer,intent(out)	      :: iso_year, iso_week, iso_weekday
      character(len=10),intent(out)   :: iso_name

DESCRIPTION
  Given a "DAT" array defining a date and time, return the ISO-8601 Week in
  two formats -- as three integer values defining the ISO year, week of year
  and weekday; and as a string of the form "yyyy-Www-d".

OPTIONS
  dat
    "DAT" array (an integer array of the same format as the array returned by
    the intrinsic DATE_AND_TIME(3f)) describing the date,

		      dat=[ year,month,day,timezone,hour,&
		       & minutes,seconds,milliseconds]

RETURNS
  iso_year
    ISO-8601 year number for the given date

  iso_week
    ISO-8601 week number for the given date

  iso_weekday
    ISO-8601 weekday number for the given date

  iso_name
    ISO-8601 Week string for the data in the form "yyyy-Www-d".

EXAMPLE
  Sample program:

      program demo_d2w
      use M_time, only : d2w
      implicit none
      integer		:: dat(8)     ! input date array
      integer		:: iso_year, iso_week, iso_weekday
      character(len=10) :: iso_name
	 call date_and_time(values=dat)
	 call d2w(dat,iso_year,iso_week,iso_weekday,iso_name)
	 write(*,'("ISO-8601 Week:   ",a)')iso_name
	 write(*,'(a,i0)')'ISO-8601 year    ',iso_year
	 write(*,'(a,i0)')'ISO-8601 week    ',iso_week
	 write(*,'(a,i0)')'ISO-8601 weekday ',iso_weekday
      end program demo_d2w

  results:

      ISO-8601 Week:   2016-W29-1
      ISO-8601 year    2016
      ISO-8601 week    29
      ISO-8601 weekday 1

DEFINITION
  The ISO-8601 date and time standard was issued by the International
  Organization for Standardization (ISO). It is used (mainly) in government
  and business for fiscal years, as well as in timekeeping.  The system
  specifies a week year atop the Gregorian calendar by defining a notation for
  ordinal weeks of the year.

  •  An ISO week-numbering year (also called ISO year informally) has 52 or 53
     full weeks. That is 364 or 371 days instead of the usual 365 or 366 days.

  •  The extra week is referred to here as a leap week, although ISO-8601

     does not use this term.
       Weeks start with Monday.

  •  The first week of a year is the week that contains the first Thursday

     of the year (and, hence, always contains 4 January).
       ISO week year numbering therefore slightly deviates from the Gregorian
       for some days close to January 1st.

CALCULATION
  The ISO-8601 week number of any date can be calculated, given its ordinal
  date (i.e. position within the year) and its day of the week.

METHOD
  Using ISO weekday numbers (running from 1 for Monday to 7 for Sunday),
  subtract the weekday from the ordinal date, then add 10. Divide the result
  by 7. Ignore the remainder; the quotient equals the week number. If the week
  number thus obtained equals 0, it means that the given date belongs to the
  preceding (week-based) year. If a week number of 53 is obtained, one must
  check that the date is not actually in week 1 of the following year.

  These two statements are assumed true when correcting the dates around
  January 1st:

  •  The number of weeks in a given year is equal to the corresponding week
     number of 28 December.

  •  January 4th is always in the first week.

ISO_NAME
  Week date representations are in the format YYYYWww-D.

    •  [YYYY] indicates the ISO week-numbering year which is slightly
       different from the traditional Gregorian calendar year.

    •  [Www] is the week number prefixed by the letter W, from W01 through
       W53.

    •  [D] is the weekday number, from 1 through 7, beginning with Monday and
       ending with Sunday.

  For example, the Gregorian date 31 December 2006 corresponds to the Sunday
  of the 52nd week of 2006, and is written

      2006-W52-7 (extended form)
      or
      2006W527 (compact form).

REFERENCE
  From Wikipedia, the free encyclopedia 2015-12-19

AUTHOR
  John S. Urban, 2015-12-19

LICENSE
   MIT
			       January 26, 2025 		  d2w(3m_time)
date_to_bas(3m_time)					  date_to_bas(3m_time)

NAME
  date_to_bas(3f) - [M_time:BAS] converts DAT date-time array to Baseday and
  Seconds (LICENSE:MIT)

SYNOPSIS
  subroutine date_to_bas(dat,bas,ierr)

      integer,intent(in)	:: dat(8)
      type(BAStime),intent(out) :: bas
      integer,intent(out)	:: ierr

DESCRIPTION
  Converts a DAT date-time array to a Baseday and Seconds type.

  In this module the BAS date and time is stored internally as a structure
  named BAStime, containing the number of days since the beginning of the MJD
  Epoch and a double representing the seconds offset from the start of this
  day.

  type BAStime

    integer :: base_day
      ! number of days since the MJD Epoch date real(kind=real64) :: secs !
      seconds from start of base_day end type BAStime

  Modified Julian Date (MJD) measures days (and fractional days) since the
  start of 17 Nov 1858 CE in Universal Time (UTC). Put another way

	 Modified Julian Date (MJD) = Julian Date (JD) - 2400000.5

  This allows for storing a date at a higher precision that the other formats
  used by the library, although sometimes that lower precision is limited
  primarily by the definition (ie. the milliseconds in a DAT could be smaller
  units).

  BAS (and MJD) starts at midnight (00:00:00) so truncating the fractional
  component of BAS always gives the same Civil Calendar day whatever the time
  of day (unlike JD).

  The seconds offset may take any double-precision value, so that any
  date/time may be expressed in terms of an offset from the same MJD day. The
  seconds field thus may exceed a single day, and may also be negative. Note
  that in floating-point math larger numbers will have a wider spacing between
  representable values, possibly decreasing the precision of results.

OPTIONS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	    dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

RETURNS
  bas
    A Baseday and Seconds variable representing the date and time found in the
    DAT array

  ierr
    Error code. If 0 no error occurred.

EXAMPLE
  Sample Program:

      program demo_date_to_bas
      use M_time, only : date_to_bas, realtime, BAStime
      use M_time, only : date_to_julian
      implicit none
      integer			 :: dat(8)
      type(BAStime)		 :: bas
      real(kind=realtime)	 :: juliandate
      integer			 :: ierr
      character(len=*),parameter :: g='(*(g0,1x))'
	 !
	 write(*,g)'date_to_bas:'
	 ! generate DAT array
	 call date_and_time(values=dat)
	 !
	 ! show DAT array
	 write(*,'("Today is:",*(i0:,":"))')dat
	 !
	 ! convert DAT to Julian
	 call date_to_julian(dat,juliandate,ierr)
	 ! show as Modified Julian Date
	 write(*,g) 'Expecting Modified Julian Date:', &
	 & juliandate - 2400000.5_realtime
	 !
	 ! convert DAT to BAS
	 call date_to_bas(dat,bas,ierr)
	 write(*,g)'Baseday and Seconds is ', bas
	 write(*,g)'converted to Modified Julian Date:', &
	 & bas%base_day +  bas%secs/86400.0d0

      end program demo_date_to_bas

  Results:

      > date_to_bas:
      > Today is:2025:1:26:-300:1:9:0:914
      > Expecting Modified Julian Date: 60701.256260578521
      > Baseday and Seconds is	60701 22140.913984179497
      > converted to Modified Julian Date: 60701.256260578521

AUTHOR
  John S. Urban, 2025

LICENSE
   MIT
			       January 26, 2025 	  date_to_bas(3m_time)
date_to_julian(3m_time) 			       date_to_julian(3m_time)

NAME
  date_to_julian(3f) - [M_time:JULIAN] converts DAT date-time array to Julian
  Date (LICENSE:MIT)

SYNOPSIS
  subroutine date_to_julian(dat,juliandate,ierr)

      integer,intent(in)	       :: dat(8)
      real(kind=realtime),intent(out)  :: juliandate
      integer,intent(out)	       :: ierr

DESCRIPTION
  Converts a DAT date-time array to a Julian Date value.

  Julian Dates (abbreviated JD) are simply a continuous count of days and
  fractions since noon Universal Time on January 1, 4713 BC (on the Julian
  calendar). Julian dates are widely used as time variables within
  astronomical software. Typically, a 64-bit floating point (double precision)
  variable can represent an epoch expressed as a Julian date to about 20
  microsecond precision.

OPTIONS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	    dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

RETURNS
  juliandate
    A Julian Date (JD) is the number of days since noon (not midnight) on
    January 1st, 4713 BC.

  ierr
    Error code. If 0 no error occurred.

EXAMPLE
  Sample Program:

      program demo_date_to_julian
      use M_time, only : date_to_julian,realtime
      implicit none
      integer		  :: dat(8)
      real(kind=realtime) :: juliandate
      integer		  :: ierr
	 ! generate DAT array
	 call date_and_time(values=dat)
	 ! show DAT array
	 write(*,'(" Today is:",*(i0:,":"))')dat
	 ! convert DAT to Julian Date
	 call date_to_julian(dat,juliandate,ierr)
	 write(*,*)'Julian Date is ',juliandate
	 write(*,*)'ierr is ',ierr
      end program demo_date_to_julian

  results:

      Today is:2016:7:19:-240:11:3:13:821
      Julian Date is	2457589.1272432986
      ierr is		 0

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025        date_to_julian(3m_time)
date_to_modified_julian(3m_time)	      date_to_modified_julian(3m_time)

NAME
  date_to_modified_julian(3f) - [M_time:MODIFIED_JULIAN] converts DAT date-
  time array to Modified Julian Date (LICENSE:MIT)

SYNOPSIS
  subroutine date_to_modified_julian(dat,modified_juliandate,ierr)

      integer,intent(in)	      :: dat(8)
      real(kind=realtime),intent(out) :: modified_juliandate
      integer,intent(out)	      :: ierr

DESCRIPTION
  Converts a DAT date-time array to a Modified Julian Date type. Simply

  Modified Julian Date (MJD) = Julian Date (JD) - 2400000.5

  Modified Julian Date (MJD) measures days (and fractional days) since the
  start of 17 Nov 1858 CE in Universal Time (UTC).

  MJD starts at midnight (00:00:00) so truncating the fractional component of
  MJD always gives the same Civil Calendard day whatever the time of day
  (unlike JD).

OPTIONS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	    dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

RETURNS
  modified_juliandate
    A Modified Julian Date (MJD) measures days (and fractional days) since the
    start of 17 Nov 1858 CE in Universal Time (UTC).

  ierr
    Error code. If 0 no error occurred.

EXAMPLE
  Sample Program:

      program demo_date_to_modified_julian
      use M_time, only : date_to_modified_julian
      use M_time, only : date_to_julian, realtime
      implicit none
      integer			 :: dat(8)
      real(kind=realtime)	 :: modified_juliandate
      real(kind=realtime)	 :: juliandate
      integer			 :: ierr
      character(len=*),parameter :: g='(*(g0,1x))'
	 !
	 ! generate DAT array
	 call date_and_time(values=dat)
	 !
	 ! show DAT array
	 write(*,'("Today is:",*(i0:,":"))')dat
	 !
	 ! convert DAT to Julian Date
	 call date_to_julian(dat,juliandate,ierr)
	 write(*,g) 'Expecting:', juliandate - 2400000.5_realtime
	 !
	 ! convert DAT to Modified Julian Date
	 call date_to_modified_julian(dat,modified_juliandate,ierr)
	 write(*,g)'Modified Julian Date is ', modified_juliandate

      end program demo_date_to_modified_julian

  Results:

      > Today is:2025:1:26:-300:1:5:31:721
      > Expecting: 60701.253839362878
      > Modified Julian Date is  60701.253839362878

AUTHOR
  John S. Urban, 2025

LICENSE
   MIT
			       January 26, 202date_to_modified_julian(3m_time)
j2d(3m_time)							  j2d(3m_time)

NAME
  j2d(3f) - [M_time:JULIAN] given a JD (Julian Date) returns a date-time array
  DAT.	(LICENSE:MIT)

SYNOPSIS
  function j2d(julian) result(dat)

      real(kind=realtime),intent(in),optional :: julian
      integer				      :: dat(8)

DESCRIPTION
  Converts a Julian Date to a DAT date-time array.

OPTIONS
  julian
    A Julian Date (JD) is the number of days since noon (not midnight) on
    January 1st, 4713 BC.  If not present, use current time.

RETURNS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

EXAMPLE
  Sample program:

      program demo_j2d
      use M_time, only : j2d, d2j, fmtdate, realtime
      implicit none
      integer,parameter   :: dp=kind(0.0d0)
      real(kind=realtime) :: today
      integer		  :: dat(8)
	 call date_and_time(values=dat) ! get the date using intrinsic
	 today=d2j(dat) 		 ! convert today to Julian Date
	 write(*,*)'Today=',fmtdate(j2d(today))
	 ! math is easy with Julian Days and Julian Dates
	 write(*,*)'Yesterday=',fmtdate(j2d(today-1.0_dp))
	 write(*,*)'Tomorrow=',fmtdate(j2d(today+1.0_dp))
      end program demo_j2d

  results:

      Today=Tuesday, July 19th, 2016 08:48:20 AM
      Yesterday=Monday, July 18th, 2016 08:48:20 AM
      Tomorrow=Wednesday, July 20th, 2016 08:48:20 AM

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		  j2d(3m_time)
julian_to_date(3m_time) 			       julian_to_date(3m_time)

NAME
  julian_to_date(3f) - [M_time:JULIAN] converts a JD(Julian Date) to a DAT
  date-time array.  (LICENSE:MIT)

SYNOPSIS
  subroutine julian_to_date(julian,dat,ierr)

      real(kind=realtime),intent(in) :: julian
      integer,intent(out)	     :: dat(8)
      integer,intent(out)	     :: ierr

DESCRIPTION
  Converts a Julian Date(JD) value to a DAT date-time array.

  Julian dates are simply a continuous count of days and fractions since noon
  Universal Time on January 1, 4713 BC (on the Julian calendar). Julian dates
  are widely used as time variables within astronomical software. Typically, a
  64-bit floating point (double precision) variable can represent an epoch
  expressed as a Julian date to about 20 microsecond precision.

OPTIONS
  julian
    Julian Date (days)

RETURNS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	       dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

  ierr
    Error code. If 0 no error occurred.

EXAMPLE
  Sample program:

       program demo_julian_to_date
       use M_time, only : julian_to_date, fmtdate, realtime
       implicit none
       integer,parameter   :: dp=kind(0.0d0)
       real(kind=realtime) :: juliandate
       integer		   :: dat(8)
       integer		   :: ierr
	  ! set sample Julian Date
	  juliandate=2457589.129_dp
	  ! create DAT array for this date
	  call julian_to_date(juliandate,dat,ierr)
	  write(*,*)'Sample Date=',fmtdate(dat)
	  ! go back one day
	  call julian_to_date(juliandate-1.0_dp,dat,ierr)
	  write(*,*)'Day Before =',fmtdate(dat)
	  ! go forward one day
	  call julian_to_date(juliandate+1.0_dp,dat,ierr)
	  write(*,*)'Day After	=',fmtdate(dat)
       end program demo_julian_to_date

  Results:

       Sample Date=Tuesday, July 19th, 2016 11:05:45 AM UTC-04:00
       Day Before =Monday, July 18th, 2016 11:05:45 AM UTC-04:00
       Day After  =Wednesday, July 20th, 2016 11:05:45 AM UTC-04:00

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025        julian_to_date(3m_time)
locale(3m_time) 					       locale(3m_time)

NAME
  locale(3f) - [M_time:DATE_PRINTING] allow for selecting languages to
  represent month and weekday names (LICENSE:MIT)

SYNOPSIS
  subroutine locale(name,month_names,weekday_names, & &
  month_names_abbr,weekday_names_abbr,IERR)

      character(len=*),intent(in)	   :: name
      character(len=*),intent(in),optional :: month_names(12)
      character(len=*),intent(in),optional :: month_names_abbr(12)
      character(len=*),intent(in),optional :: weekday_names(7)
      character(len=*),intent(in),optional :: weekday_names_abbr(7)
      integer,intent(out)		   :: ierr

DESCRIPTION
  given a pre-defined locale name or strings to substitute for month names and
  weekday names provide some basic support for non-POSIX labels in date
  representation.

  The parameters are default character types and so may be limited to the
  basic ASCII character set, but are typically limited to the extended ASCII
  set.

  This is only a basic attempt to support internationalization and currently
  just supports basic substitution of the default POSIX names with the
  alternate strings. As support for UTF-8 grows among Fortran compilers
  something more robust will hopefully emerge to provide full
  internationalization of the date representations.

OPTIONS
  name
    predefined name or reserved name "user"

  month_names
    12 month names

  weekday_names
    7 weekday names

  month_names_abbr
    12 month name abbreviations

  weekday_names_abbr
    7 weekday name abbreviations

  ierr
    if non-zero an error occurred

  The NAME parameter may be a pre-defined name or the special name "user".
  The current pre-defined names are

     'bokmal','catalan','czech','dansk'/'danish','deutsch'/'german','dutch',
     'eesti'/'estonian','english','finnish','french','galego'/'galician',
     'hrvatski'/'croation','hungarian','icelandic','italian','korean',
     'lithuanian','norwegian','nynorsk','polish','portuguese','romanian',
     'slovak','slovene'/'slovenian','spanish','swedish','turkish'

  These non-ISO-8859 character sets are defined in terms of ISO-8859 but will
  not work on most platforms

     'greek', 'russian','thai', 'hebrew','japanese'

  The remaining reserved names take special actions

    •  POSIX load POSIX names

    •  LANGUAGE use value of environment variable LANGUAGE

    •  user placeholder indicating to expect at least one of the optional
       values to be set

    •  reset,ISO-8601 reset back to initial defaults

    •  show print user-defined values to stdout

    •  chars dump characters from chars([(i,i=0,255)])

EXAMPLE
  Sample program:

      program demo_locale
      use M_time, only : locale, now
      implicit none
	 call locale('POSIX')
	 write(*,*)now()
	 call locale('french')
	 write(*,*)now()
	 call mine()
	 write(*,*)now()
      contains
      subroutine mine()
      character(len=*),parameter :: months(12)=[ character(len=9) :: &
      &'JANUARY','FEBRUARY','MARCH    ','APRIL	','MAY	   ','JUNE    ', &
      &'JULY   ','AUGUST  ','SEPTEMBER','OCTOBER','NOVEMBER','DECEMBER']
      character(len=*),parameter :: weekdays(7)=[character(len=9) :: &
      &'MONDAY','TUESDAY','WEDNESDAY','THURSDAY','FRIDAY','SATURDAY','SUNDAY']
      character(len=3),parameter :: short_months(12)=months(:)(1:3)
      character(len=3),parameter :: short_weekdays(7)=weekdays(:)(1:3)
      integer :: ierr
	call locale('user',months,short_months,weekdays,short_weekdays,ierr)
      end subroutine mine
      end program demo_locale

  Results:

      Sunday, September 29th, 2024 7:55:00 PM UTC-04:00
      dimanche, septembre 29th, 2024 7:55:00 PM UTC-04:00
      JUL, SEPTEMBER 29th, 2024 7:55:00 PM UTC-04:00

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	       locale(3m_time)
m2d(3m_time)							  m2d(3m_time)

NAME
  m2d(3f) - [M_time:MODIFIED_JULIAN] given a MJD (Modified Julian Date)
  returns a date-time array DAT.  (LICENSE:MIT)

SYNOPSIS
  function m2d(modified_julian) result(dat)

      real(kind=realtime),intent(in),optional :: modified_julian
      integer				      :: dat(8)

DESCRIPTION
  Converts a Modified Julian Date to a DAT date-time array.

OPTIONS
  modified_juliandate
    A Modified Julian Date (MJD) measures days (and fractional days) since the
    start of 17 Nov 1858 CE in Universal Time (UTC).  If not present, use
    current time.

RETURNS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

EXAMPLE
  Sample program:

      program demo_m2d
      use M_time, only : m2d, d2m, fmtdate, realtime
      implicit none
      integer,parameter   :: dp=kind(0.0d0)
      real(kind=realtime) :: today
      integer		  :: dat(8)
	 call date_and_time(values=dat) ! get the date using intrinsic
	 today=d2m(dat) 		 ! convert today to Julian Date
	 write(*,*)'Today=',fmtdate(m2d(today))
	 ! math is easy with Julian Days and Julian Dates
	 write(*,*)'Yesterday=',fmtdate(m2d(today-1.0_dp))
	 write(*,*)'Tomorrow=',fmtdate(m2d(today+1.0_dp))
      end program demo_m2d

  Results:

      >  Today=Sunday, January 26th, 2025 1:08:25 AM UTC-05:00
      >  Yesterday=Saturday, January 25th, 2025 1:08:25 AM UTC-05:00
      >  Tomorrow=Monday, January 27th, 2025 1:08:25 AM UTC-05:00

AUTHOR
  John S. Urban, 2025

LICENSE
   MIT
			       January 26, 2025 		  m2d(3m_time)
untitled()							    untitled()

	      [GPF Home Page]

   NAME
  M_time(3fm) - [M_time::INTRO] Fortran module for manipulating and presenting
  time and date values as defined in ISO 8601:1988 (LICENSE:MIT)

   DESCRIPTION
  The M_time(3f) Fortran module and associated utility programs provide date
  and time-related procedures. Both a procedural and OOP (Object Oriented
  Programming) interface are provided. The primary conversion procedures are
  provided as both a simple function and a subroutine returning error flags
  and finer-grained control. Each routine is accompanied by a man-page which
  includes a sample program for that procedure. This is also provided in HTML
  format both in individual pages and a book format. The man-page example
  programs, unit tests and additional examples are all provided in the
  distribution package.

  The M_time(3f) module

  •  provides for formatting dates.

  •  facilitates simple computations using time and date values in the recent
     era.

  •  allows for macro-level timing of code.

  The M_TIME(3f) module complements the DATE_AND_TIME(3f) procedure, which is
  the standard intrinsic subroutine that returns the current date and time in
  the Gregorian calendar.  That is, the primary way this module represents
  dates is as an integer array with the same meaning for elements as defined
  by the DATE_AND_TIME(3f) routine. In addition it can calculate or read many
  other date representations such as ...

  •  Julian and Modified Julian Dates

  •  (Modified) Days and Seconds

  •  Unix Epoch Dates

  •  High-level date formatting

  •  Ordinal days of the year

  •  days of the week

  •  ISO-8601 week numbers

  •  month and weekday names

  Julian and Unix Epoch Dates are particularly useful for manipulating dates
  in simple numeric expressions.

  The extensive formatting options include showing SYSTEM_CLOCK(3f) and
  CPU_USAGE(3f) information along with Gregorian date information, allowing
  for the easy incorporation of timing information into program messages. In
  addition to conventional Civilian Calendar dates, the module supports the
  ISO-8601 standard methods of displaying dates.

  A Fortran-callable sleep(3c)/usleep(3c) procedure is also provided.

   SYNOPSIS
  Summary of functions

   UNIX EPOCH
  date_to_unix(dat,UNIXTIME,IERR) or d2u(dat) result(UNIXTIME) %epoch()
  Convert date array to Unix Time unix_to_date(unixtime,DAT,IERR) or

  u2d(unixtime) result(DAT)
    Convert Unix Time to date array

   JULIAN
  julian_to_date(julian,DAT,IERR) or

  j2d(julian) result(DAT)
    Convert Julian Date to date array date_to_julian(dat,JULIAN,IERR) or
    d2j(dat) result(JULIAN) %julian() Converts date array to Julian Date

   MODIFIED JULIAN
  modified_julian_to_date(modified_julian,DAT,IERR) or

  m2d(modified_julian) result(DAT)
    Convert Modified Julian Date to date array
    date_to_modified_julian(dat,MODIFIED_JULIAN,IERR) or d2m(dat)
    result(MODIFIED_JULIAN) %modified_julian() Converts date array to Modified
    Julian Date

   BASEDAY AND SECONDS
  bas_to_date(bas,DAT,IERR) or

  b2d(bas) result(DAT)
    Convert Baseday And Seconds (BAS) to date array date_to_bas(dat,BAS,IERR)
    or d2m(dat) result(BAS) %nbsp; Converts date array to Baseday And Seconds
    date

   WEEK OF YEAR
  d2w(dat,ISO_YEAR,ISO_WEEK,ISO_WEEKDAY,ISO_NAME)
    calculate iso-8601 Week- numerically and as string yyyy-Www-d
    w2d(iso_year,iso_week,iso_weekday,DAT) or

  w2d(iso_string,DAT,[IERR])
    calculate date DAT given iso-8601 Week date (numerically or as a string
    yyyy-Www-d) `

   ORDINAL DAY
  d2o(dat) result(ORDINAL) %ordinal() given date array return ordinal day of
  year, Jan 1st=1 ordinal_to_date(ordinal,year,DAT) or

  o2d(ordinal,[year]) result(DAT)
    given ordinal day of year return date array, Jan 1st=1 ordinal_seconds()
    return seconds since beginning of year

   PRINTING DATES
  fmtdate(dat,format) result(TIMESTR) %format([string]) Convert date array to
  string using format

  fmtdate_usage(indent)
    display macros recognized by fmtdate(3f)

  now(format) result(TIMESTR)
    return string representing current time given format

  box_month(dat,CALEN)
    print specified month into character array

   MONTH NAME
  mo2v(month_name) result(MONTH_NUMBER)
    given month name return month number

  v2mo(month_number) result(MONTH_NAME)
    given month number return month name

  mo2d(month_name,year) result(DAT)
    return date array for first day of given month name in specified year

   DAY OF WEEK
  dow(dat,[WEEKDAY],[DAY],IERR) %weekday() Convert date array to day of the
  week as number(Mon=1) and name

   LOCALE
  locale(name,month_names,weekday_names,month_names_abbr,weekday_names_ab

  br,IERR)
    basic ASCII locale definition

   ASTROLOGICAL
  easter(year,dat)
    calculate month and day Easter falls on for given year

  moon_fullness(dat) result(FULLNESS)
    percentage of moon phase from new to full

  phase_of_moon(dat) result(PHASE)
    return name for phase of moon for given date

   DURATION
  sec2days(seconds) result(DHMS)
    converts seconds to string D-HH:MM:SS

  days2sec(string) result(SECONDS)
    converts string D-HH:MM:SS or NNdNNhNNmNNs to seconds

   READING DATES
  guessdate(anot,DAT)
    Converts a date string to a date array, in various formats

   C INTERFACE
  system_sleep(wait_seconds)
    Call sleep(3c) or usleep(3c)

   FORMATTING OPTIONS IN FMTDATE
  You can easily use Julian Dates and Unix Epoch Times to add and subtract
  times from dates or to calculate the interval between dates. But JEDs and
  UETs and even the Gregorian Calendar arrays in the DAT arrays are not the
  way we typically describe a date on the Civilian Calendar. So the
  fmtdate(3f) routine lets us print a DAT array in a variety of familiar
  styles.

  The fmtdate(3f) and now(3f) procedures let you display a Gregorian date
  using either keywords for standard formats or using macros in a user-
  specified formatting string. A formatting string may contain the following
  macros:

  Description
    Example

   Base time array:
    (1) %Y -- year, yyyy				2016
    (2) %M -- month of year, 01 to 12			07
    (3) %D -- day of month, 01 to 31			27
	%d -- day of month, with suffix (1st, 2nd,...)	27th
    (4) %Z -- minutes from UTC				-0240m
	%z -- -+hh:mm from UTC				-04:00
	%T -- -+hhmm  from UTC				-0400
    (5) %h -- hours, 00 to 23				21
	%H -- hour (1 to 12, or twelve-hour clock)	09
	%N -- midnight< AM <=noon; noon<= PM <midnight	PM
    (6) %m -- minutes, 00 to 59 			24
    (7) %s -- sec, 00 to 59				22
    (8) %x -- milliseconds 000 to 999			512
   Conversions:
	%E -- Unix Epoch time				1469669062.5129952
	%e -- integer value of Unix Epoch time		1469669063
	%F -- Modified Julian Date			60400.559
	%f -- integer value of Modified Julian Date	60400
	%G -- Baseday and Seconds			(60400,4000.55944412)
	%g -- integer value of Baseday and Seconds	60400
	%J -- Julian date				2457597.559
	%j -- integer value of Julian Date(Julian Day)	2457597
	%O -- Ordinal day (day of year) 		209
	%o -- whole days since Unix Epoch date		17009
	%U -- day of week, 1..7 Sunday=1		4
	%u -- day of week, 1..7 Monday=1		3
	%i -- ISO week of year 1..53			30
	%I -- iso-8601 week-numbering date(yyyy-Www-d)	2016-W30-3
    Names:
	%l -- abbreviated month name			Jul
	%L -- full month name				July
	%w -- first three characters of weekday 	Wed
	%W -- weekday name				Wednesday
	%p -- phase of moon				New
	%P -- percent of way from new to full moon	-1%
    Literals:
	%% -- a literal %				%
	%t -- tab character
	%b -- blank character
	%B -- exclamation(bang) character
	%n -- new line (system dependent)
	%q -- single quote (apostrophe)
	%Q -- double quote
    Duration:
	%a -- Time since now (age) as d-hh:mm:ss       1-20:14:40
	%A -- Time since now (age) as seconds	       123456.890
    Program timing:
	%c -- CPU_TIME(3f) output		       .78125000000000000E-001
	%C -- number of times this routine is used     1
	%S -- seconds since last use of this format    .0000000000000000
	%k -- time in seconds from SYSTEM_CLOCK(3f)    588272.750
	%K -- time in clicks from SYSTEM_CLOCK(3f)     588272750
    Help:
	%? -- call fmtdate_usage

  If no percent (%) is found in the format one of several alternate
  substitutions occurs.

    If the format is composed entirely of one of the following keywords the
    following substitution occurs:

      "iso-8601",
      "iso"	   ==> %Y-%M-%DT%h:%m:%s%z
			  Ex: 2017-08-26T18:56:33,510912700-04:00
      "iso-8601W",
      "isoweek"    ==> %I
			  Ex: 2024-W26-6
      "sql"	   ==> "%Y-%M-%D %h:%m:%s.%x"
			  Ex: "2024-06-29 08:42:14.311"
      "sqlday"	   ==> "%Y-%M-%D"
			  Ex: "2024-06-29"
      "sqltime"    ==> "%h:%m:%s.%x"
			  Ex: "08:42:31.528"
      "dash"	   ==> %Y-%M-%D
			  Ex: 2024-06-29
      "rfc-2822"   ==> %w, %D %l %Y %h:%m:%s %T
			  Ex: Mon, 14 Aug 2006 02:34:56 -0600
      "rfc-3339"   ==> %Y-%M-%DT%h:%m:%s%z
			  Ex: 2006-08-14 02:34:56-06:00
      "date"	   ==> %w %l %D %h:%m:%s UTC%z %Y
			  Ex: Sat Jun 29 08:43:14 UTC-04:00 2024
      "short"	   ==> %w, %l %d, %Y %H:%m:%s %N UTC%z
			  Ex: Sat, Jun 29th, 2024 8:43:18 AM UTC-04:00
      "long"," "   ==> %W, %L %d, %Y %H:%m:%s %N UTC%z
			  Ex: Saturday, June 29th, 2024 8:43:23 AM UTC-04:00
      "suffix"	   ==> %Y%D%M%h%m%s
			  Ex: 20242906084327
      "formal"	   ==> The %d of %L %Y
			  Ex: The 29th of June 2024
      "lord"	   ==> the %d day of %L in the year of our Lord %Y
			  Ex: the 29th day of June in the year of our Lord 2024
      "easter"	   ==> Easter day: the %d day of %L in the year of our Lord %Y
			  Ex: Easter day: ...
			  the 31st day of March in the year of our Lord 2024
      "all"	   ==> A SAMPLE OF DATE FORMATS
			  Civil Calendar:   Saturday June 29th
			  Civil Date:		    2024-06-29 08:44:29 -04:00
			  Julian Date:		    2460491.0308968634
			  Unix Epoch Time:  1719665069.4890008
			  Day Of Year:		    181
			  ISO-8601 week:	    2024-W26-6

    otherwise the following words are replaced with the most common macros.
    For duplicate names the lowercase one is a numeric value string and all
    uppercase is an alphanumeric string:

      String	     Macro  Example
      year	     %Y     2016

      month	     %M     07
      MONTH	     %L     July
      Month|Mth      %l     Jul

      day	     %D     27
      DAY	     %d     27th

      hour	     %h     21

      HOUR	     %H     11
      GOOD	     %N     AM

      minute	     %m     24

      second	     %s     22

      weekday	     %u     3
      WEEKDAY	     %W     Thursday
      Weekday|wkday  %w     Thu

      timezone	     %T     -0400   (+-HHMM)
      TIMEZONE	     %z     -04:00  (+-HH:MM)
      Timezone	     %Z     -240m   (+-MMMMm)

      epoch	     %e     1469669063

      julian	     %j     2457597
      MJD	     %f     57597

      ordinal	     %O     209

      age	     %A     100-20:30:40
      AGE	     %a     20900.3030

      usage|help|?   %?     call fmtdate_usage()

    If none of these keywords are found then every letter that is a macro is
    assumed to have an implied percent in front of it. For example:

      YMDhms ==> %Y%M%D%h%m%s ==> 20160727212422

   OOPS INTERFACE
  If you prefer an Object-oriented interface the M_time__oop module (included
  with the M_time module source) provides an OOP interface to the M_time
  module.

   EXAMPLES
  The following example program demonstrates the extensive options available
  for formatting a date as well as how to use the module to calculate dates
  such as "Yesterday" and "Tomorrow".

  Sample program:

  ! yesterday, today, tomorrow

       program demo_M_time
       use M_time, only: j2d, d2j, u2d, d2u, fmtdate, realtime
       integer :: dat(8)
       real(kind=realtime) :: julian, unixtime
       character(len=*),parameter :: iso_fmt='%Y-%M-%DT%h:%m:%s.%x%z'
       character(len=:),allocatable :: friendly

	  friendly='%W, %L %d, %Y %H:%m:%s %N' ! a nice friendly format

	  call date_and_time(values=dat)  ! current time is placed in array

	  write(*,*)'Today'
	  write(*,*)'ISO       ',fmtdate(dat,iso_fmt)
	  write(*,*)'Friendly  ',fmtdate(dat,friendly)
	  write(*,*)'ISO week  ',fmtdate(dat,'%I')

	  julian=d2j(dat)
	  unixtime=d2u(dat)

	  write(*,*)'Yesterday' ! subtract a day from scalar time and print
	  write(*,*)'	       ',fmtdate(u2d(unixtime-86400),iso_fmt)
	  write(*,*)'	       ',fmtdate(j2d(julian-1.0),friendly)
	  write(*,*)'	       ',fmtdate(j2d(julian-1.0),'%I')

	  write(*,*)'Tomorrow'	! add a day to scalar time and print
	  write(*,*)'	       ',fmtdate(u2d(unixtime+86400),iso_fmt)
	  write(*,*)'	       ',fmtdate(j2d(julian+1.0),friendly)
	  write(*,*)'	       ',fmtdate(j2d(julian+1.0),'%I')

	  write(*,*)'Next Week'  ! add a week to scalar time and print
	  write(*,*)'	       ',fmtdate(u2d(unixtime+7*86400),iso_fmt)
	  write(*,*)'	       ',fmtdate(j2d(julian+7.0),friendly)
	  write(*,*)'	       ',fmtdate(j2d(julian+7.0),'%I')

       end program demo_M_time

  Sample output ...

   Today
   ISO	     2015-12-22T08:07:34.025-0300
   Friendly  Tuesday, December 22nd, 2015 08:07:34 AM
   ISO week  2015-W52-2
   Yesterday
	     2015-12-21T08:07:34.025-0300
	     Monday, December 21st, 2015 08:07:34 AM
	     2015-W52-1
   Tomorrow
	     2015-12-23T08:07:34.025-0300
	     Wednesday, December 23rd, 2015 08:07:34 AM
	     2015-W52-3
   Next Week
	     2015-12-29T08:07:34.025-0300
	     Tuesday, December 29th, 2015 08:07:34 AM
	     2015-W53-2

   DEFINITIONS
  A "date_and_time" array "DAT" has the same format as the array of values
  generated by the Fortran intrinsic DATE_AND_TIME(3f).  That is, it is an
  8-element integer array containing year, month, day, Time zone difference
  from UTC in minutes, hour, minutes, seconds, and milliseconds of the second.
  This array represents a date on the Proleptic Gregorian Calendar.

  The Proleptic Gregorian Calendar assumes the Gregorian Calendar existed back
  to the beginning of the Julian Day calendar (4713 BC). This means historic
  dates will often be confused, as the Julian Calendar was used in the USA
  until 1752-09-03, for example. The Gregorian Calendar was formally decreed
  on 1582-10-15 but was not adapted in many countries. The Julian Calendar was
  first used around 45 BC.

  Note that the Proleptic Gregorian Calendar includes a year zero (0). It is
  frequently used in computer software to simplify the handling of older
  dates. For example, it is the calendar used by MySQL, SQLite, PHP, CIM,
  Delphi, Python and COBOL. The Proleptic Gregorian Calendar is explicitly
  required for all dates before 1582 by ISO 8601:2004 (clause 4.3.2.1 The
  Gregorian calendar) if the partners to information exchange agree.

  Unix Epoch Time (UET) is defined as the number of seconds since 00:00:00 on
  January 1st. 1970, UTC.

  A JD is defined as a Julian Date. JD days start at noon (not at midnight).
  4713-01-01 BC at noon is defined as JD 0.0.

  If you are not familiar with them, in this context Julian Dates and Unix
  Epoch Times are scalar numbers that allow for easy computations using dates
  (to go back one day just subtract one from a Julian Date, for example).
  Since these values are generally not considered intelligible, routines are
  included to convert between these scalar values and the date array so human-
  readable results can be obtained.

  Modified Julian Date (MJD) measures days (and fractional days) since the
  start of 17 Nov 1858 CE in Universal Time (UTC).  Julian Date (JD) measures
  days (and fractional days) since noon on 1 January, 4713 BCE in Universal
  Time (UTC). As an expression

  Modified Julian Date (MJD) = Julian Date (JD) - 2400000.5

	    Baseday And Seconds is a date composed of two values. The first
	    is an integer representing a Modified Julian Day. The second is
	    a double-precision value representing an offset from the start
	    of this base day in seconds .

  type BAStime

    integer
      :: base_day ! whole days since the MJD Epoch date

    real(kind=real64) :: secs
      ! offset in seconds from start of BASE_DAY end type BAStime

	      This facilitates storing a date at a higher precision that the
	      other formats used by the library (although sometimes that lower
	      precision is limited primarily by the definition -- for example
	      the milliseconds in a DAT could be smaller units).

	      This format uses seconds for the units of the fractional day
	      component instead of fractions of a day as is used by JD and
	      MJD, as seconds are often the unit of measure in many
	      computations.

	      BAS days start at midnight (00:00:00) so truncating the
	      fractional component always gives the same Civil Calendar day
	      whatever the time of day (unlike JD).

	      The seconds offset may take any double-precision value, so that
	      any date/time may be expressed in terms of an offset from the
	      same BAS day. Given that, floating point precision is finite so
	      it is intended that the offset value be relatively small or the
	      spacing between representable numbers becomes so large that
	      precise small intervals cannot be represented. The seconds field
	      thus may exceed a single day but should generally have a small
	      exponent to retain precision, and may also be negative.

	      Coordinated Universal Time (French: Temps universel coordonn'e),
	      abbreviated as UTC, is the primary time standard by which the
	      world regulates clocks and time. It is within about 1 second of
	      mean solar time at 0o longitude;[1] it does not observe daylight
	      saving time. It is one of several closely related successors to
	      Greenwich Mean Time (GMT). For most purposes, UTC is considered
	      interchangeable with GMT, but GMT is no longer precisely defined
	      by the scientific community.

   LIMITATIONS
  Like most collections of date and time procedures M_time is not a high-
  precision library that accounts internally for leap seconds and relativistic
  effects.

  M_time(3f) is intended for use in the recent era and is not appropriate for
  use with historical dates that used some other calendar scheme such as the
  Julian Calendar. That is, you have to remember to account for conversions to
  other calendar systems when using historical dates.

  When Daylight Savings is in effect calculations will generally be correct,
  as the date model includes a timezone value; but you are responsible for
  ensuring dates you create use the correct timezone value or otherwise
  account for Daylight Savings Time as needed.

  Currently, dates are manipulated using the current system timezone, which
  can typically be set using the environment variable TZ. So if you desire to
  set the default timezone you generally set the environment variable before
  executing your program. This is compatible with current observed behavior
  for the intrinsic procedure DATE_AND_TIME(3f) with compilers I have tested
  with, but does not seem to be a specified behavior as far as the standard is
  concerned. That is, DATE_AND_TIME(3f) returns a vector that contains a
  current time zone, but does not specify how a current time zone can be
  explicitly set. Since this library is intentionally designed to complement
  DATE_AND_TIME(3f) it adopts the same behavior. A routine to let you set a
  default time zone could be added in the future.

  Note the environment variable can be set using put_environment_variable(3f)
  from the libGPF library:

  use M_system, only : put_environment_variable call
  put_environment_variable('TZ','America/New_York',ierr)

   SEE ALSO
  Utility programs that use the M_time(3f) module:

	    + now(1) prints a date in many formats
	    + ttee(1) a filter which timestamps stdout from another command
	    + month(1) which lets you print simple calendars
	    + days2sec(1) converts dd-hh:mm:ss or NNdNNhNNmNNs to seconds
	    + sec2days(1) converts seconds to dd-hh:mm:ss
	    + paws(1) pause until specified time or for specified interval

	    The ISO-8601 standard is often used for business-related
	    transactions.

	    There are C/C++ intrinsics which provide much of the same
	    functionality that should be bindable to Fortran via the
	    ISO_C_BINDING module.

	    The Fortran Wiki fortranwiki.org contains information on other
	    libraries and modules that provide date-time procedures.

	    If you care about Leap Seconds, Orbital Mechanics, GPS/Satellite
	    communications, and Astronomy the high-precision NASA SPICElib
	    Fortran library is worth a look. It is well tested for
	    manipulating high-precision dates.

			       January 26, 2025 		    untitled()
M_time__oop(3m_time)					  M_time__oop(3m_time)

NAME
  M_time__oop(3fm) - [M_time::INTRO::OOPS] OOP interface for M_time(3fm)
  (LICENSE:MIT)

SYNOPSIS
  use M_time__oop, only : date_time ! the type includes the following
  operators:

  ! operator(+)

  ! operator(-)

  ! operator(>)

  ! operator(<)

  ! operator(<=)

  ! operator(>=)

  ! operator(==)

  ! operator(/=)

     TYPE(date_time) :: mydate

	mydate%year
	mydate%month
	mydate%day
	mydate%tz
	mydate%hour
	mydate%minute
	mydate%second
	mydate%millisecond

	call mydate%init()

	mydate%format('')
	mydate%ordinal()
	mydate%weekday()
	mydate%epoch()
	mydate%julian()
	dat=mydate%datout()
	mydate%delta(year=NN, month=NN, day=NN, tz=NN, hour=NN, minute=NN,
	second=NN, millisecond=NN, week=NN, duration='DD-HH:MM:SS.XX')

DESCRIPTION
  An object-oriented interface to the M_time module. The following example
  program demonstrates and documents the interface

EXAMPLES
  sample program

      program demo_M_time__oop
      !
      ! This is an example using the object-oriented class/type model
      ! This is essentially the same functionality as the procedures
      ! in the procedural module M_time(3fm), but allows for Object
      ! Oriented syntax:
      !
      use M_time__oop,only : date_time
      ! The type includes the operators ...
      !  operator(+)
      !  operator(-)
      !  operator(>)
      !  operator(<)
      !  operator(<=)
      !  operator(>=)
      !  operator(==)
      !  operator(/=)
      implicit none
      integer,parameter :: dp=kind(0.0d0)
      integer	      :: dat(8)
      TYPE(date_time) :: event
      TYPE(date_time) :: otherdate
      TYPE(date_time) :: answer

      character(len=*),parameter :: iso_fmt='%Y-%M-%DT%h:%m:%s.%x%z'
	 ! DIFFERENT INITIALIZATION STYLES
	 ! (Still debating on how best to do this)
	 write(*,*)
	 write(*,'(a)')'Various initialization styles'

	 ! DEFINE type(date_time) WITH CONSTRUCTOR
	 otherdate=date_time()
	 print *,'DEFAULT CONSTRUCTOR %format() 	      ',&
	 & otherdate%format()
	 print *,'DEFAULT CONSTRUCTOR %format("")	      ',&
	 & otherdate%format("")
	 print *,'DEFAULT CONSTRUCTOR %format(user-specified) ',&
	 & otherdate%format(iso_fmt)
	 print *,'DEFAULT CONSTRUCTOR %format("USA")	      ',&
	 & otherdate%format("USA")

	 otherdate=date_time(1492,10,12,0,0,0,0,0)
	 print *,'DEFAULT CONSTRUCTOR setting values	      ',&
	 & otherdate%format()

	 otherdate=date_time(2016,6,11)
	 print *,'DEFAULT CONSTRUCTOR with partial values     ',&
	 & otherdate%format()

	 otherdate=date_time(year=2016,month=6,day=11,tz=-240,&
	 & hour=21,minute=09,second=11,millisecond=500)
	 print *,'DEFAULT CONSTRUCTOR with values by name     ',&
	 & otherdate%format()

	 otherdate=date_time([1776,7,4,0,0,0,0,0])
	 print *,'CONSTRUCTOR with a dat array		      ',&
	 & otherdate%format()

	 otherdate=date_time([1776,7,4])
	 print *,'CONSTRUCTOR with a partial dat array	      ',&
	 & otherdate%format()

	 ! the init() method supports several methods
	 ! initialize to current time using INIT
	 call otherdate%init()
	 ! initialize to current time using INIT
	 call otherdate%init(type="now")

	 ! initialize to beginning of Unix Epoch Time
	 call otherdate%init(type="epoch")
	 ! Note
	 ! currently, DATE_TIME DATE array is set to Unix Epoch
	 ! start USING LOCAL TIMEZONE
	 ! whereas default constructor is using default of Unix Epoch
	 ! start using Z time (GMT or UTC time)

	 ! initialize with a DAT array using INIT,
	 ! compatible with DATE_AND_TIME VALUES(8)
	 call otherdate%init(dat=[1970,1,1,0,0,0,0,0])
	 ! using INIT with ordered values
	 call otherdate%init(2016,6,11,-300,23,1,0,0)
	 ! using INIT with names
	 call otherdate%init(year=2016,month=6,day=11,&
	 & tz=-300,hour=23,minute=1,second=0,millisecond=0)
	 !
	 ! take current date and exercise the OOP interface
	 ! initialize to current time using INIT
	 call event%init()
	 write(*,*)
	 write(*,*)'Print members of type(DATE_TIME)'
	 ! show derived type
	 write(*,404)'EVENT=',event
	 404 format(1x,a,i0,*(",",i0:))

	 ! MEMBERS ( basic time values are all integers)
	 ! print members of type
	 write(*,101)'%year	   Year................... ',event%year
	 write(*,101)'%month	   Month.................. ',event%month
	 write(*,101)'%day	   Day.................... ',event%day
	 write(*,101)'%tz	   Timezone............... ',event%tz
	 write(*,101)'%hour	   Hour................... ',event%hour
	 write(*,101)'%minute	   Minute................. ',event%minute
	 write(*,101)'%second	   Second................. ',event%second
	 write(*,101)'%millisecond Millisecond............ ',event%millisecond

	 ! PRINT METHODS OF TYPE
	 write(*,*)'Print methods of type(DATE_TIME)'
	 write(*,101)'%ordinal	   Ordinal day of year.... ',  event%ordinal()
	 write(*,101)'%weekday	   Weekday................ ',  event%weekday()
	 101 format(1x,a,i0)
	 ! DOUBLE PRECISION VALUES EASILY MANIPULATED MATHEMATICALLY
	 write(*,202)'%epoch	  Unix epoch time........ ',  event%epoch()
	 write(*,202)'%julian	  Julian date............ ',  event%julian()
	 202 format(1x,a,g0)

	 ! FORMATTED STRINGS (many strings possible.
	 ! Takes the same format string as fmtdate(3f))
	 write(*,*)
	 write(*,'(a)')' Formatted Strings (%format("STRING") &
	 & -- see fmtdate(3f) for format descriptions'
	 ! abbreviated month name	      %l  Dec
	 write(*,303)'Short month............ ',&
	 & event%format("%l")
	 !
	 ! full month name		      %L  December
	 write(*,303)'Month.................. ',&
	 & event%format("%L")
	 !
	 ! first three characters of weekday  %w  Sat
	 write(*,303)'Short week............. ',&
	 & event%format("%w")
	 !
	 ! weekday name 		      %W  Saturday
	 write(*,303)'Week .................. ',&
	 & event%format("%W")
	 !
	 ! with no percent (%) characters
	 write(*,303)'Calendar Time ......... ',&
	 & event%format("Y-M-D h:m:s.x z")
	 !
	 ! keywords with no percent (%) characters
	 write(*,303)'Calendar Time ......... ',&
	 & event%format('"year-month-day &
	 & hour:minute:second.millisecond timezone"')
	 !
	 write(*,*)event%format('Longer format.......... &
	 &"%W, %L %d, %Y %H:%m:%s %N"') ! a nice friendly format
	 !
	 303 format(1x,a,'"',a,'"')

	 ! convert date_time to integer array
	 ! (maybe to use with module M_TIME base procedures)
	 dat=event%datout()
	 write(*,*)
	 write(*,404)'DAT=',dat

	 ! OVERLOADED OPERATORS (add and subtract)
	 ! a date_time object can have seconds added
	 answer=event+1*86400.0_dp
	 !
	 ! a nice friendly format
	 write(*,*)answer%format('TOMORROW="%W, %L %d, %Y %H:%m:%s %N"')
	 !
	 ! a date_time object can have seconds subtracted
	 answer=event-1*86400.0_dp
	 ! a nice friendly format
	 write(*,*)answer%format('YESTERDAY="%W, %L %d, %Y %H:%m:%s %N"')
	 !
	 ! if both operands are DATE_TIME objects a subtraction
	 ! finds the time in seconds between the two dates
	 write(*,*)'DIFFERENCE (subtracting one date_time from another)=',&
	 & answer-event

	 ! OVERLOADED OPERATORS (logical comparisons)
	 ! NOTE COMPARISONS ARE PERFORMED BY
	 ! CONVERTING TIMES TO INTEGER SECONDS
	 write(*,*)'> ',event==event   ,event<event   ,event>event &
	 & ,event<=event   ,event>=event   ,event/=event
	 !
	 write(*,*)'> ',event==answer  ,event<answer  ,event>answer  &
	 & ,event<=answer  ,event>=answer  ,event/=answer
	 !
	 write(*,*)'> ',answer==event  ,answer<event  ,answer>event  &
	 & ,answer<=event  ,answer>=event  ,answer/=event

	 ! %DELTA easily lets you change dates by common increments
	 write(*,*)
	 write(*,404)'%DELTA tests starting with date ',event%delta()
	 !
	 write(*,*) event%format("			       &
	 &%W, %L %d, %Y %H:%m:%s %N")

	 write(*,*)'Remember years and months are not constant units'

	 answer=event%delta(year=1)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(YEAR=+1)	    %W, %L %d, %Y %H:%m:%s %N")
	 answer=event%delta(year=-1)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(YEAR=-1)	    %W, %L %d, %Y %H:%m:%s %N")

	 answer=event%delta(month=24)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(MONTH=+24)	    %W, %L %d, %Y %H:%m:%s %N")
	 !
	 answer=event%delta(month=-24)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(MONTH=-24)	    %W, %L %d, %Y %H:%m:%s %N")

	 answer=event%delta(week=1)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(WEEK=+1)	    %W, %L %d, %Y %H:%m:%s %N")
	 !
	 answer=event%delta(week=-1)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(WEEK=-1)	    %W, %L %d, %Y %H:%m:%s %N")

	 answer=event%delta(day=1)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(DAY=+1) 	    %W, %L %d, %Y %H:%m:%s %N")
	 !
	 answer=event%delta(day=-1)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(DAY=-1) 	    %W, %L %d, %Y %H:%m:%s %N")

	 answer=event%delta(hour=4)
	 write(*,*)answer%format(&
	 !
	 & "FOR %%DELTA(HOUR=+4)	    %W, %L %d, %Y %H:%m:%s %N")
	 answer=event%delta(hour=-4)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(HOUR=-4)	    %W, %L %d, %Y %H:%m:%s %N")

	 answer=event%delta(minute=180)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(MINUTE=+180)	    %W, %L %d, %Y %H:%m:%s %N")
	 !
	 answer=event%delta(minute=-180)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(MINUTE=-180)	    %W, %L %d, %Y %H:%m:%s %N")

	 answer=event%delta(second=1800)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(SECOND=+1800)	    %W, %L %d, %Y %H:%m:%s %N")
	 !
	 answer=event%delta(second=-1800)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(SECOND=-1800)	    %W, %L %d, %Y %H:%m:%s %N")

	 answer=event%delta(millisecond=10000)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(MILLISECOND=+10000) %W, %L %d, %Y %H:%m:%s %N")
	 !
	 answer=event%delta(millisecond=-10000)
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(MILLISECOND=-10000) %W, %L %d, %Y %H:%m:%s %N")

	 answer=event%delta(year=3,month=2,day=100,hour=200,&
	 & week=-1,minute=300,second=1000,millisecond=-10000)
	 write(*,*)answer%format(&
	 !
	 &"FOR %%DELTA(year=3,month=2,day=100,hour=200,&
	 &week=-1,minute=300,second=1000,millisecond=100000)&
	 & %W, %L %d, %Y %H:%m:%s %N")

	 answer=event%delta(duration="1-20:30:40.50")
	 write(*,*)answer%format(&
	 & "FOR %%DELTA(DURATION='1-20:30:40.50')&
	 & %W, %L %d, %Y %H:%m:%s %N")

      end program demo_M_time__oop

  Sample output:

   Various initialization styes
    DEFAULT CONSTRUCTOR %format()		1970-01-01T00:00:00.000+00:00
    DEFAULT CONSTRUCTOR %format("")		1970-01-01T00:00:00.000+00:00
    DEFAULT CONSTRUCTOR %format(user-specified) 1970-01-01T00:00:00.000+00:00
    DEFAULT CONSTRUCTOR %format("USA")	 Thursday, January 1st, 1970 12:00:00 AM
    DEFAULT CONSTRUCTOR setting values		1492-10-12T00:00:00.000+00:00
    DEFAULT CONSTRUCTOR with partial values	2016-06-11T00:00:00.000+00:00
    DEFAULT CONSTRUCTOR with values by name	2016-06-11T21:09:11.500-04:00
    CONSTRUCTOR with a dat array		1776-07-04T00:00:00.000+00:00
    CONSTRUCTOR with a partial dat array	1776-07-04T20:00:00.000-04:00

    Print members of type(DATE_TIME)
    EVENT=2020,10,24,-240,21,49,54,105
    %year	 Year................... 2020
    %month	 Month.................. 10
    %day	 Day.................... 24
    %tz 	 Timezone............... -240
    %hour	 Hour................... 21
    %minute	 Minute................. 49
    %second	 Second................. 54
    %millisecond Millisecond............ 105
    Print methods of type(DATE_TIME)
    %ordinal	 Ordinal day of year.... 298
    %weekday	 Weekday................ 6
    %epoch	Unix epoch time........ 1603590594.1049695
    %julian	Julian date............ 2459147.5763206594

    Formatted Strings (%format("STRING")
    -- see fmtdate(3f) for format descriptions
    Short month............ "Oct"
    Month.................. "October"
    Short week............. "Sat"
    Week .................. "Saturday"
    Calendar Time ......... "2020-10-24 21:49:54.105 -04:00"
    Calendar Time ......... ""2020-10-24 21:49:54.105 -0400""
    Longer format.......... "Saturday, October 24th, 2020 9:49:54 PM"

    DAT=2020,10,24,-240,21,49,54,105
    TOMORROW="Sunday, October 25th, 2020 9:49:54 PM"
    YESTERDAY="Friday, October 23rd, 2020 9:49:54 PM"
    DIFFERENCE (subtracting one date_time from another)=  -86400.000000000000
    >  T F F T T F
    >  F F T F T T
    >  F T F T F T

    %DELTA tests starting with date 2020,10,24,-240,21,49,54,105
				 Saturday, October 24th, 2020 9:49:54 PM
    Remember years and months are not constant units
    FOR %DELTA(YEAR=+1) 	   Sunday, October 24th, 2021 9:49:54 PM
    FOR %DELTA(YEAR=-1) 	   Thursday, October 24th, 2019 9:49:54 PM
    FOR %DELTA(MONTH=+24)	   Wednesday, October 26th, 2022 9:49:54 PM
    FOR %DELTA(MONTH=-24)	   Wednesday, October 24th, 2018 9:49:54 PM
    FOR %DELTA(WEEK=+1) 	   Saturday, October 31st, 2020 9:49:54 PM
    FOR %DELTA(WEEK=-1) 	   Saturday, October 17th, 2020 9:49:54 PM
    FOR %DELTA(DAY=+1)		   Sunday, October 25th, 2020 9:49:54 PM
    FOR %DELTA(DAY=-1)		   Friday, October 23rd, 2020 9:49:54 PM
    FOR %DELTA(HOUR=+4) 	   Sunday, October 25th, 2020 1:49:54 AM
    FOR %DELTA(HOUR=-4) 	   Saturday, October 24th, 2020 5:49:54 PM
    FOR %DELTA(MINUTE=+180)	   Sunday, October 25th, 2020 12:49:54 AM
    FOR %DELTA(MINUTE=-180)	   Saturday, October 24th, 2020 6:49:54 PM
    FOR %DELTA(SECOND=+1800)	   Saturday, October 24th, 2020 10:19:54 PM
    FOR %DELTA(SECOND=-1800)	   Saturday, October 24th, 2020 9:19:54 PM
    FOR %DELTA(MILLISECOND=+10000) Saturday, October 24th, 2020 9:50:04 PM
    FOR %DELTA(MILLISECOND=-10000) Saturday, October 24th, 2020 9:49:44 PM
    FOR %DELTA(year=3,month=2,day=100,hour=200,week=-1,minute=300,
    second=1000,millisecond=100000) Thursday, April 4th, 2024 11:06:24 AM
    FOR %DELTA(DURATION='1-20:30:40.50') Monday, October 26th, 2020 6:20:34 PM

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	  M_time__oop(3m_time)
mo2d(3m_time)							 mo2d(3m_time)

NAME
  mo2d(3f) - [M_time:MONTH_NAME] given month name return DAT date-time array
  for beginning of that month in specified year (LICENSE:MIT)

SYNOPSIS
  function mo2d(month_name,year) result(dat)

	 character(len=*),intent(in) :: month_name
	 integer,intent(in),optional :: year
	 integer		     :: dat(8)

DESCRIPTION
  Given a Common Calendar month name, return the date as a "DAT" array for the
  1st day of the month. An optional year that defaults to the current year may
  be specified.

OPTIONS
  month_name
    A string representing a Common Calendar month name.

  year
    Optional year. Defaults to current year

RETURNS
  dat
    An integer array that has the same structure as the array returned by the
    Fortran intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

EXAMPLE
  Sample program:

      program demo_mo2d
      use M_time, only : mo2d
      implicit none
	 write(*,'("MARCH:",*(i0:,":"))')mo2d('March')
      end program demo_mo2d

  Results:

	   > MARCH:2016:3:1:-240:0:0:0:0

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		 mo2d(3m_time)
mo2v(3m_time)							 mo2v(3m_time)

NAME
  mo2v(3f) - [M_time:MONTH_NAME] given month name return month number (1-12)
  of that month (LICENSE:MIT)

SYNOPSIS
  elemental function mo2v(month_name) result(imonth)

       character(len=*),intent(in):: month_name ! month name
       integer			  :: imonth	! month number

DESCRIPTION
  Given a string representing the name or abbreviation of a Gregorian Calendar
  month return a number representing the position of the month in the calendar
  starting with 1 for January and ending with 12 for December.

OPTIONS
  month_name
    name or abbreviation of month. Case is ignored.

RETURNS
  imonth
    month number returned. If the name is not recognized a -1 is returned.

EXAMPLE
  Sample program:

      program demo_mo2v
      use M_time, only : mo2v
      implicit none
	 write(*,*)mo2v("April")
	 write(*,*)mo2v('Apr')
	 write(*,*)mo2v('sexember')
	 write(*,*)mo2v('unknown')  ! returns -1
      end program demo_mo2v

  results:

	>  4
	>  4
	> -1
	> -1

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		 mo2v(3m_time)
modified_julian_to_date(3m_time)	      modified_julian_to_date(3m_time)

NAME
  modified_julian_to_date(3f) - [M_time:MODIFIED_JULIAN] converts a
  MJD(Modified Julian Date) to a DAT date-time array.  (LICENSE:MIT)

SYNOPSIS
  subroutine modified_julian_to_date(modified_julian,dat,ierr)

      real(kind=realtime),intent(in) :: modified_julian
      integer,intent(out)	     :: dat(8)
      integer,intent(out)	     :: ierr

DESCRIPTION
  Converts a Modified Julian Date(MJD) value to a DAT date-time array.

  Modified Julian Date (MJD) = Julian Date (JD) - 2400000.5

  Modified Julian Date (MJD) measures days (and fractional days) since the
  start of 17 Nov 1858 CE in Universal Time (UTC). Julian Date (JD) measures
  days (and fractional days) since noon on 1 January, 4713 BCE in Universal
  Time (UTC).

  MJD starts at midnight (00:00:00) so truncating the fractional component of
  MJD always gives the same Civil Calendar day whatever the time of day
  (unlike JD).

OPTIONS
  modified_julian
    A Modified Julian Date (MJD) measures days (and fractional days) since the
    start of 17 Nov 1858 CE in Universal Time (UTC).

RETURNS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	       dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

  ierr
    Error code. If 0 no error occurred.

EXAMPLE
  Sample program:

       program demo_modified_julian_to_date
       use M_time, only : modified_julian_to_date, fmtdate, realtime
       implicit none
       integer,parameter   :: dp=kind(0.0d0)
       real(kind=realtime) :: modified_juliandate, tomorrow, yesterday
       integer		   :: dat(8)
       integer		   :: ierr
	  ! set sample Modified Julian Date
	  modified_juliandate=60700.503682349771_dp
	  ! create DAT array for this date
	  call modified_julian_to_date(modified_juliandate,dat,ierr)
	  write(*,*)'Sample Date=',fmtdate(dat)
	  !
	  ! go back one day
	  yesterday= modified_juliandate-1.0
	  call modified_julian_to_date(yesterday,dat,ierr)
	  write(*,*)'Day Before =',fmtdate(dat)
	  !
	  ! go forward one day
	  tomorrow= modified_juliandate+1
	  call modified_julian_to_date(tomorrow,dat,ierr)
	  write(*,*)'Day After	=',fmtdate(dat)
	  !
       end program demo_modified_julian_to_date

  Results:

       >  Sample Date=Saturday, January 25th, 2025 7:05:18 AM UTC-05:00
       >  Day Before =Friday, January 24th, 2025 7:05:18 AM UTC-05:00
       >  Day After  =Sunday, January 26th, 2025 7:05:18 AM UTC-05:00

AUTHOR
  John S. Urban, 2025

LICENSE
   MIT
			       January 26, 202modified_julian_to_date(3m_time)
moon_fullness(3m_time)					moon_fullness(3m_time)

NAME
  moon_fullness(3f) - [M_time:ASTROLOGICAL] return percentage of moon phase
  from new to full (LICENSE:MIT)

SYNOPSIS
  function moon_fullness(dat)

     integer,intent(in) :: dat(8)
     integer		:: moon_fullness

DESCRIPTION
  This procedure is used to support the %P field descriptor for the
  fmtdate(3f) routine.

  The moon circles the earth every 29.530588853 days on average, so pick a
  starting point and count. A new moon occurred at January 6, 2000, 18:14 UTC.
  Then it is easy to count the number of days since the last new moon. This is
  an approximate calculation.

OPTIONS
  dat
    DAT Date array describing input date

RESULTS
  moon_fullness
    0 is a new or dark moon, 100 is a full moon, + for waxing and - for
    waning.

EXAMPLES
  Sample:

      program demo_moon_fullness
      use M_time, only : now
      use M_time, only : phase_of_moon
      use M_time, only : moon_fullness
      implicit none
      integer :: dat(8)
	 ! generate DAT array
	 call date_and_time(values=dat)
	 ! show DAT array
	 write(*,'(" Today is:",*(i0:,":"))')dat
	 ! the %p and %P fields are supported by fmtdate(3f)
	 write(*,*)&
	 &now('The phase of the moon is %p, with a fullness of %P')
	 write(*,'(1x,*(a))',advance='no')&
	 &'The phase of the moon is ',trim( phase_of_moon(dat)),','
	 write(*,'(1x,a,i0,a)')&
	 &'with a fullness of ', moon_fullness(dat),'%'
      end program demo_moon_fullness

  Sample output:

       Today is:2018:11:3:-240:20:18:44:245
       The phase of the moon is Waning crescent, with a fullness of -30%
       The phase of the moon is Waning crescent, with a fullness of -30%

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	moon_fullness(3m_time)
now(3m_time)							  now(3m_time)

NAME
  now(3f) - [M_time:DATE_PRINTING] return string representing current time
  given one of many formats to present with (LICENSE:MIT)

SYNOPSIS
  function now(format) result(timestr)

      character(len=*),intent(in)     :: format  ! input format string
      character(len=:),allocatable    :: timestr ! formatted date

DESCRIPTION
  The now(3f) function is a call to the fmtdate(3f) function using the current
  date and time. That is, it is a convenient way to print the current date and
  time.

OPTIONS
  format
    string describing how to format the current date and time.	For a complete
    description of the formatting macros supported see fmtdate_usage(3f).

RETURNS
  timestr
    formatted output string representing date

EXAMPLE
  Sample Program:

      program demo_now
      use M_time, only : now
      implicit none
	 write(*,*)now("The current date is &
	    &year/month/day hour:minute:second timezone")
	 write(*,*)now("The current date is &
	    &WEEKDAY at HOUR GOOD, MONTH DAY, year")
	 write(*,*)now("The current date is &
	    &%w, %l %d, %Y %H:%m:%s %N")
	 write(*,*)now("iso")
      end program demo_now
  ``` Results:

   >  The current date is 2024/06/28 14:56:36 -0400
   >  The current date is Friday at 2 PM, June 28th, 2024
   >  The current date is Fri, Jun 28th, 2024 2:56:36 PM
   >  2024-06-28T14:56:36-04:00

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		  now(3m_time)
o2d(3m_time)							  o2d(3m_time)

NAME
  o2d(3f) - [M_time:ORDINAL_DAY] converts Ordinal day to DAT date-time array
  (LICENSE:MIT)

SYNOPSIS
  function o2d(ordinal,[year]) result(dat)

      integer,intent(in) :: ordinal  ! the day of the year
      integer,optional	 :: year     ! year
      integer		 :: dat(8)   ! date time array

DESCRIPTION
  Given an Ordinal day of the year return a date in the form of a "DAT" array.

OPTIONS
  ordinal
    The day of the year for the given year, where Jan 1st=1.

  year
    An optional year for the ordinal day. If not present the current year is
    assumed.

RETURNS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	       dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

  The timezone value is from the current time on the current platform.

EXAMPLE
  Sample program:

      program demo_o2d
      use M_time, only : o2d,fmtdate
      implicit none
      integer :: year
	 do year=2004,2008
	    write(*,'(*(g0))')&
	    & '100th day of ',year,' is ',fmtdate(o2d(100,year))
	 enddo
	 write(*,'(*(g0))')'100th day of this year is ',fmtdate(o2d(100))
      end program demo_o2d

  Results:

      > 100th day of 2004 is Friday, April 9th, 2004 12:00:00 AM UTC-05:00
      > 100th day of 2005 is Sunday, April 10th, 2005 12:00:00 AM UTC-05:00
      > 100th day of 2006 is Monday, April 10th, 2006 12:00:00 AM UTC-05:00
      > 100th day of 2007 is Tuesday, April 10th, 2007 12:00:00 AM UTC-05:00
      > 100th day of 2008 is Wednesday, April 9th, 2008 12:00:00 AM UTC-05:00
      > 100th day of this year is Monday, April 10th, 2023 12:00:00 AM UTC-05:00

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		  o2d(3m_time)
ordinal_seconds(3m_time)			      ordinal_seconds(3m_time)

NAME
  ordinal_seconds(3f) - [M_time:ORDINAL_DAY] seconds since beginning of year
  (LICENSE:MIT)

SYNOPSIS
  function ordinal_seconds()

      integer :: ordinal_seconds

DESCRIPTION
  Return number of seconds since beginning of current year.

  Before using this routine consider the consequences if the application is
  running at the moment a new year begins.

EXAMPLE
  sample program

      program demo_ordinal_seconds
      use M_time, only : ordinal_seconds
      implicit none
      character(len=*),parameter :: gen='(*(g0))'
      integer	       :: i, istart, iend
      real,volatile    :: x
      istart = ordinal_seconds()
      x = 0.0
      do i = 1, 1000000000
	 x = x+sqrt(real(i))
      enddo
      print gen, 'x=',x
      iend = ordinal_seconds()
      print gen, 'that took ',iend-istart,' seconds'
      print gen, iend,'-',istart,'=',iend-istart
      end program demo_ordinal_seconds

  Results:

      > x=0.549755814E+12
      > that took 4 seconds
      > 23659912-23659908=4

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025       ordinal_seconds(3m_time)
ordinal_to_date(3m_time)			      ordinal_to_date(3m_time)

NAME
  ordinal_to_date(3f) - [M_time:ORDINAL_DAY] when given a valid year and day
  of the year returns the DAT array for the date (LICENSE:MIT)

SYNOPSIS
  subroutine ordinal_to_date(yyyy, ddd, dat)

	integer, intent(in)   :: yyyy
	integer, intent(in)   :: ddd
	integer, intent(out)  :: dat

DESCRIPTION
  When given a valid year, YYYY, and day of the year, DDD, returns the date as
  a DAT date array

OPTIONS
  yyyy
    known year

  ddd
    known ordinal day of the year

RETURNS
  dat
    DAT array describing the date

EXAMPLE
  Sample program:

      program demo_ordinal_to_date
      use M_time, only : ordinal_to_date
      implicit none
      integer :: yyyy, ddd, mm, dd, yy
      integer :: dat(8)
      integer :: i, iostat
      character(len=:),allocatable :: fakefile(:)
	fakefile=[character(len=80) :: ' 2024 273 ','2024 001']
	do i=1,size(fakefile)
	   ! Enter year YYYY and ordinal day of year DD
	   read(fakefile(i),*,iostat=iostat)yyyy,ddd
	   if(iostat/=0)exit
	   ! recover month and day from year and day number.
	   call ordinal_to_date(yyyy, ddd, dat)
	   yy=dat(1)
	   mm=dat(2)
	   dd=dat(3)
	   write(*,'(*(g0))')'For Year ',yyyy,' and Ordinal day ',ddd
	   write(*,'(*(g0))')' Month is ',mm,' and Day of Month is ',dd, &
	   & ' and Year is ',yy
	enddo
      end program demo_ordinal_to_date

  Result:

      > For Year 2024 and Ordinal day 273
      > Month is 9 and Day of Month is 29 and Year is 2024
      > For Year 2024 and Ordinal day 1
      > Month is 1 and Day of Month is 1 and Year is 2024

			       January 26, 2025       ordinal_to_date(3m_time)
phase_of_moon(3m_time)					phase_of_moon(3m_time)

NAME
  phase_of_moon(3f) - [M_time:ASTROLOGICAL] return name for phase of moon for
  given date (LICENSE:MIT)

SYNOPSIS
  function phase_of_moon(dat)

     integer,intent(in) 	   :: dat(8)
     character(len=:),allocatable  :: phase_of_moon

DESCRIPTION
  Phases Of The Moon

  This procedure is used to support the %p field descriptor for the
  fmtdate(3f) routine.

  The moon circles the earth every 29.530588853 days on average, so pick a
  starting point and count. A new moon occurred at Julian date 2451550.1
  (January 6, 2000, 18:14 UTC). Then it is easy to count the number of days
  since the last new moon. This is an approximate calculation.

  There are eight generally recognized phases of the moon in common use

    •  new or dark

    •  waxing crescent

    •  first quarter

    •  waxing gibbous

    •  full

    •  waning gibbous

    •  last quarter

    •  waning crescent

  To calculate the phase of the moon simply divide the days since the last new
  moon by eight and select the appropriate phase.

  Note that technically the four states (new, first quarter, full, third
  quarter) are events not phases. That is to say, the moon is technically only
  new for an instant.

EXAMPLES
  Sample:

    program demo_phase_of_moon
    use M_time, only : now
    use M_time, only : phase_of_moon
    use M_time, only : moon_fullness
    implicit none
    integer :: dat(8)
     ! generate DAT array
     call date_and_time(values=dat)
     ! show DAT array
     write(*,'(" Today is:",*(i0:,":"))')dat
     ! the %p and %P fields are supported by fmtdate(3f)
     write(*,*)&
     & now('The phase of the moon is %p, with a fullness of %P')
     write(*,'(1x,*(a))',advance='no')&
     & 'The phase of the moon is ',trim( phase_of_moon(dat)),','
     write(*,'(1x,a,i0,a)')'with a fullness of ',moon_fullness(dat),'%'
    end program demo_phase_of_moon

  Sample output:

      Today is:2018:11:3:-240:20:18:44:245
      The phase of the moon is Waning crescent, with a fullness of -30%
      The phase of the moon is Waning crescent, with a fullness of -30%

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	phase_of_moon(3m_time)
sec2days(3m_time)					     sec2days(3m_time)

NAME
  sec2days(3f) - [M_time:DURATION] convert seconds to string of form dd-
  hh:mm:ss (LICENSE:MIT)

SYNOPSIS
  function sec2days(seconds,crop) result(dhms)

      real(kind=realtime),intent(in) :: seconds
	or
      integer,intent(in)	     :: seconds
	or
      real,intent(in)		     :: seconds
	or
      character(len=*)		     :: seconds

      logical,intent(in),optional    :: crop
      character(len=:),allocatable   :: dhms

DESCRIPTION
  Given a number of seconds convert it to a string of the form

	dd-hh:mm:ss

  where dd is days, hh hours, mm minutes and ss seconds.

OPTIONS
  seconds
    number of seconds to convert to string of form dd-hh:mm:ss. May be of type
    INTEGER, REAL, REAL(KIND=REALTIME), or CHARACTER.

    CHARACTER strings may be of the form [NNd][NNh][NNm][NNs][NNw].
    Case,spaces and underscores are ignored. Allowed aliases for d,h,m, and s
    units are

		      d -  days,day
		      m -  minutes,minute,min
		      h -  hours,hour,hrs,hr
		      s -  seconds,second,sec

    The numeric values may represent floating point numbers.

  crop
    if .true., remove leading zero day values or day and hour values.
    Optional, defaults to .false. .

RETURNS
  dmhs
    the returned string of form [d:h:]m:s

EXAMPLE
  Sample Program:

      program demo_sec2days
      use M_time, only : sec2days
      implicit none
      integer,parameter :: dp=kind(0.0d0)
	 write(*,*)sec2days(129860)
	 write(*,*)sec2days(80000.0_dp)
	 write(*,*)sec2days(80000.0,crop=.true.)
	 write(*,*)sec2days('1 day 2.0hr 100 min 300.0seconds')
      end program demo_sec2days

  results:

      1-12:04:20
      0-22:13:20
      22:13:20
      1-03:45:00

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	     sec2days(3m_time)
system_sleep(3m_time)					 system_sleep(3m_time)

NAME
  system_sleep(3f) - [M_time:C_INTERFACE] call C sleep(3c) or usleep(3c)
  procedure (LICENSE:MIT)

SYNOPSIS
  subroutine system_sleep(wait_seconds)

	integer,intent(in)  :: wait_seconds
	   or
	real,intent(in)  :: wait_seconds

DESCRIPTION
  The system_sleep(3f) routine uses the intrinsic ISO_C_BINDING interface to
  call the C sleep(3c) procedure or usleep(3c) routine.

OPTIONS
  wait_seconds
    integer,real or doubleprecision number of seconds for process to sleep.

EXAMPLE
  Sample program:

      program demo_system_sleep
      use M_time, only : system_sleep, now
      implicit none
      integer :: i
	 !
	 write(*,'(a)')"Time before integer call is: ",now()
	 call system_sleep(4)
	 write(*,'(a)')"Time after integer call is: ",now()
	 !
	 write(*,'(a)')"Time before real call is: ",now()
	 call system_sleep(4.0)
	 write(*,'(a)')"Time after real call is: ",now()
	 !
	 write(*,'(a)')"Time before loop is: ",now()
	 do i=1,1000
	    call system_sleep(4.0/1000.0)
	 enddo
	 write(*,'(a)')"Time after loop is: ",now()
	 !
      end program demo_system_sleep

  results

       Time before integer call is:
       Sunday, July 17th, 2016 2:29:45 AM UTC-0240
       Time after integer call is:
       Sunday, July 17th, 2016 2:29:49 AM UTC-0240
       Time before real call is:
       Sunday, July 17th, 2016 2:29:49 AM UTC-0240
       Time after real call is:
       Sunday, July 17th, 2016 2:29:53 AM UTC-0240
       Time before loop is:
       Sunday, July 17th, 2016 2:29:53 AM UTC-0240
       Time after loop is:
       Sunday, July 17th, 2016 2:30:09 AM UTC-0240

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	 system_sleep(3m_time)
u2d(3m_time)							  u2d(3m_time)

NAME
  u2d(3f) - [M_time:UNIX_EPOCH] given Unix Epoch Time returns DAT date-time
  array (LICENSE:MIT)

SYNOPSIS
  function u2d(unixtime) result(dat)

      class(*),intent(in),optional	:: unixtime
      ! integer
      ! real
      ! real(kind=realtime)

      integer				:: dat(8)

DESCRIPTION
  Given Unix Epoch Time returns DAT date-time array

OPTIONS
  unixtime
    The "Unix Epoch" time, or the number of seconds since 00:00:00 on January
    1st, 1970, UTC. If not present, use current time.

RETURNS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

EXAMPLE
  Sample program:

      program demo_u2d
      use M_time, only : u2d, d2u, fmtdate, realtime
      implicit none
      integer,parameter :: dp=kind(0.0d0)
      real(kind=realtime) :: today
      integer :: dat(8)
	 ! get the date using intrinsic
	 call date_and_time(values=dat)
	 ! convert today to Julian Date
	 today=d2u(dat)
	 write(*,*)'Today=',fmtdate(u2d(today))
	 ! subtract day
	 write(*,*)'Yesterday=',fmtdate(u2d(today-86400.0_dp))
	 ! add day
	 write(*,*)'Tomorrow=',fmtdate(u2d(today+86400.0_dp))
      end program demo_u2d

  results:

      Today=Tuesday, July 19th, 2016 11:10:08 AM
      Yesterday=Monday, July 18th, 2016 11:10:08 AM
      Tomorrow=Wednesday, July 20th, 2016 11:10:08 AM

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		  u2d(3m_time)
unix_to_date(3m_time)					 unix_to_date(3m_time)

NAME
  unix_to_date(3f) - [M_time:UNIX_EPOCH] converts Unix Epoch Time to DAT date-
  time array (LICENSE:MIT)

SYNOPSIS
  subroutine unix_to_date(unixtime,dat,ierr)

      real(kind=realtime),intent(in) :: unixtime
      integer,intent(out)	     :: dat(8)
      integer,intent(out)	     :: ierr

DESCRIPTION
  Converts a Unix Epoch Time (UET) to a DAT date-time array.

OPTIONS
  unixtime
    The "Unix Epoch" time, or the number of seconds since 00:00:00 on January
    1st, 1970, UTC; of type real(kind=realtime).

RETURNS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

		dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

  ierr
    Error code. If 0 no error occurred.

EXAMPLE
  Sample program:

       program demo_unix_to_date
       use M_time, only : unix_to_date, u2d, fmtdate, realtime
       implicit none
       integer,parameter :: dp=kind(0.0d0)
       real(kind=realtime)	     :: unixtime
       ! seconds in a day
       real(kind=realtime),parameter :: DAY=86400.0_dp
       integer			     :: dat(8)
       integer			     :: ierr
	  ! sample Unix Epoch time
	  unixtime=1468939038.4639933_dp
	  ! create DAT array for today
	  call unix_to_date(unixtime,dat,ierr)
	  write(*,*)'Sample Date=',fmtdate(dat)
	  ! go back one day
	  call unix_to_date(unixtime-DAY,dat,ierr)
	  ! subtract day and print
	  write(*,*)'Day Before =',fmtdate(dat)
	  ! go forward one day
	  call unix_to_date(unixtime+DAY,dat,ierr)
	  ! add day print
	  write(*,*)'Day After	=',fmtdate(dat)
       end program demo_unix_to_date

  Results:

      Sample Date=Tuesday, July 19th, 2016 10:37:18 AM
      Day Before =Monday, July 18th, 2016 10:37:18 AM
      Day After  =Wednesday, July 20th, 2016 10:37:18 AM

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	 unix_to_date(3m_time)
v2mo(3m_time)							 v2mo(3m_time)

NAME
  v2mo(3f) - [M_time:MONTH_NAME] returns the month name of a Common month
  number (LICENSE:MIT)

SYNOPSIS
  function v2mo(imonth,short) result(month_name)

      integer,intent(in)	   :: imonth	  ! month number (1-12)
      character(len=:),allocatable :: month_name  ! month name
      logical,intent(in),optional  :: short

DESCRIPTION
  Given a Common Calendar month number, return the name of the month as a
  string.

OPTIONS
  imonth
    Common month number (1-12). If out of the allowable range the month name
    returned will be 'UNKNOWN'.

  short
    Flag whether to return short or long name

RETURNS
  month_name
    A string representing a month name or the word 'UNKNOWN'

EXAMPLE
  Sample program:

      program demo_v2mo
      use M_time, only : v2mo
      implicit none
      integer :: i
	 write(*,*)(v2mo(i),i=1,13)
      end program demo_v2mo

  results:

      January
      February
      March
      April
      May
      June
      July
      August
      September
      October
      November
      December
      UNKNOWN.

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		 v2mo(3m_time)
w2d(3m_time)							  w2d(3m_time)

NAME
  w2d(3f) - [M_time:WEEK_OF_YEAR] calculate DAT date-time array from iso-8601
  numeric Week values or from string "yyyy-Www-d" (LICENSE:MIT)

SYNOPSIS
  either

	subroutine w2d(iso_year,iso_week,iso_weekday,dat)

	 integer,intent(in)	 :: iso_year, iso_week, iso_weekday
	 integer,intent(out)	 :: dat(8)     ! output date array

  or

	subroutine w2d(iso_week,dat,ierr)

	 character(len=*),intent(in)  :: iso8601_week
	 integer,intent(out)	      :: dat(8)     ! output date array
	 integer,intent(out),optional :: ierr

DESCRIPTION
  Given an ISO-8601 week return a "DAT" array defining a date and time, The
  ISO-8601 is supplied as three integer values defining the ISO year, week of
  year and weekday.

OPTIONS
  iso_year
    ISO-8601 year number for the given date

  iso_week
    ISO-8601 week number for the given date.  Valid values are from 1 to 53.

  iso_weekday
    ISO-8601 weekday number for the given date.  Valid values are from 1 to 7,
    where 1 is Monday.

  iso8601_week
    ISO-8601 Week string for the data in the form "yyyy-Www-D", "yyyyWwwD",
    "yyyy-Www", and "yyyyWww" where yyyy is the year, ww is the iso_week, and
    D is the weekday.

RETURNS
  dat
    "DAT" array (an integer array of the same format as the array returned by
    the intrinsic DATE_AND_TIME(3f)) describing the date to be used

		      dat=[ year,month,day,timezone,hour,&
		       & minutes,seconds,milliseconds]

  ierr
    optional error code result. If non-zero an error occurred.	If an error
    occurs and IERR is not present the program terminates.

NOTES
  If D is omitted 1 is returned although this does not appear in the iso-8601
  standard at the current time.

  The returned dat array is currently always assumed to have the local
  timezone. This might be changed to always assume ZULU time.

EXAMPLE
  Sample program:

      program demo_w2d
      use M_time, only : w2d, fmtdate
      implicit none
	write(*,'(a)')&
	& 'Given Monday 29 December 2008 is written "2009-W01-1"'
	call printit(2009,1,1)
	write(*,'(a)')&
	& 'Given Sunday 3 January 2010 is written "2009-W53-7"'
	call printit(2009,53,7)
	write(*,'(a)')&
	& 'Given the Gregorian date Sun 31 December 2006 &
	&is written 2006-W52-7'
	call printit(2006,52,7)
	write(*,'(a)')&
	& 'Given 27 September 2008 is 2008-W39-6'
	call printit(2008,39,6)

	string : block
	   character(len=*),parameter :: array(4)=[character(len=80) ::  &
	   & '2008-W39-6', '2008W396', '2008-W39', '2008W39' ]
	   integer  :: dat(8)
	   integer  :: i
	   do i=1,size(array)
	      write(*,'(a)')&
	      & 'Given string '//array(i)
	      call w2d(array(i),dat)
	      write(*,'(a,i0)')'RESULT: 	 '
	      write(*,'(a,*(i0:,","))')'   DAT array	    ',dat
	      write(*,'(a,/,67("="))')'    '//fmtdate(dat,'long')
	   enddo
	endblock string
      contains
      subroutine printit(iso_year,iso_week,iso_weekday)
      ! ISO-8601 Week: 2016-W29-1
      integer  :: iso_year, iso_week, iso_weekday
      ! input date array
      integer  :: dat(8)
       call w2d(iso_year,iso_week,iso_weekday,dat)
       write(*,'(a,i0)')'GIVEN: 	  '
       write(*,'(a,i0)')'ISO-8601 year	  ',iso_year
       write(*,'(a,i0)')'ISO-8601 week	  ',iso_week
       write(*,'(a,i0)')'ISO-8601 weekday ',iso_weekday
       write(*,'(a,i0)')'RESULT:	  '
       write(*,'(a,*(i0:,","))')'   DAT array	     ',dat
       write(*,'(a,/,67("="))')'    '//fmtdate(dat,'long')
      end subroutine printit
  end program demo_w2d

  Results:

      Given Monday 29 December 2008 is written "2009-W01-1"
      GIVEN:
      ISO-8601 year    2009
      ISO-8601 week    1
      ISO-8601 weekday 1
      RESULT:
	 DAT array	  2008,12,29,-240,0,0,0,0
	  Monday, December 29th, 2008 12:00:00 AM UTC-04:00
      =========================================================
      Given Sunday 3 January 2010 is written "2009-W53-7"
      GIVEN:
      ISO-8601 year    2009
      ISO-8601 week    53
      ISO-8601 weekday 7
      RESULT:
	 DAT array	  2010,1,3,-240,0,0,0,0
	  Sunday, January 3rd, 2010 12:00:00 AM UTC-04:00
      =========================================================
      Given the Gregorian date Sun 31 December 2006 is written 2006-W52-7
      GIVEN:
      ISO-8601 year    2006
      ISO-8601 week    52
      ISO-8601 weekday 7
      RESULT:
	 DAT array	  2006,12,31,-240,0,0,0,0
	  Sunday, December 31st, 2006 12:00:00 AM UTC-04:00
      =========================================================
      Given 27 September 2008 is 2008-W39-6
      GIVEN:
      ISO-8601 year    2008
      ISO-8601 week    39
      ISO-8601 weekday 6
      RESULT:
	 DAT array	  2008,9,27,-240,0,0,0,0
	  Saturday, September 27th, 2008 12:00:00 AM UTC-04:00
      =========================================================

DEFINITION
  The ISO-8601 date and time standard was issued by the International
  Organization for Standardization (ISO). It is used (mainly) in government
  and business for fiscal years, as well as in timekeeping.  The system
  specifies a week year atop the Gregorian calendar by defining a notation for
  ordinal weeks of the year.

  An ISO week-numbering year (also called ISO year informally) has 52 or 53
  full weeks. That is 364 or 371 days instead of the usual 365 or 366 days.
  The extra week is referred to here as a leap week, although ISO-8601 does
  not use this term. Weeks start with Monday.  The first week of a year is the
  week that contains the first Thursday of the year (and, hence, always
  contains 4 January). ISO week year numbering therefore slightly deviates
  from the Gregorian for some days close to January 1st.

METHOD
  Calculating a date given the year, week number and weekday

  This method requires that one know the weekday of 4 January of the year in
  question. Add 3 to the number of this weekday, giving a correction to be
  used for dates within this year.

  Method: Multiply the week number by 7, then add the weekday. From this sum
  subtract the correction for the year. The result is the

  ordinal date, which can be converted into a calendar date.
    If the ordinal date thus obtained is zero or negative, the date belongs to
    the previous calendar year; if greater than the number of days in the
    year, to the following year.

  Example: year 2008, week 39, Saturday (day 6) Correction for 2008: 5 + 3 = 8
  (39 x 7) + 6 = 279 279 - 8 = 271 Ordinal day 271 of a leap year is day 271 -
  244 = 27 September Result: 27 September 2008

ISO_NAME
  Week date representations are in the format YYYY-Www ,YYYYWww, YYYY-Www-D or
  YYYYWwwD

    •  [YYYY] indicates the ISO week-numbering year which is slightly
       different from the traditional Gregorian calendar year.

    •  [Www] is the week number prefixed by the letter W, from W01 through
       W53.

    •  [D] is the weekday number, from 1 through 7, beginning with Monday and
       ending with Sunday.

  For example, the Gregorian date 31 December 2006 corresponds to the Sunday
  of the 52nd week of 2006, and is written

      2006-W52-7 (extended form)
      or
      2006W527 (compact form).

REFERENCE
  From Wikipedia, the free encyclopedia 2016-08-08

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		  w2d(3m_time)
date_to_unix(3m_time)					 date_to_unix(3m_time)

NAME
  date_to_unix(3f) - [M_time:UNIX_EPOCH] converts DAT date-time array to Unix
  Epoch Time (LICENSE:MIT)

SYNOPSIS
  subroutine date_to_unix(dat,unixtime,ierr)

      integer,intent(in)	       :: dat(8)
      real(kind=realtime),intent(out)  :: unixtime
      integer,intent(out)	       :: ierr

DESCRIPTION
  Converts a DAT date-time array to a UET (Unix Epoch Time).

OPTIONS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	       dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

RETURNS
  unixtime
    The "Unix Epoch" time, or the number of seconds since 00:00:00 on January
    1st, 1970, UTC.

  ierr
    Error code. If 0 no error occurred.

EXAMPLE
  Sample program:

       program demo_date_to_unix
       use M_time, only : date_to_unix, realtime
       implicit none
       integer		   :: dat(8)
       real(kind=realtime) :: unixtime
       integer		   :: ierr
	  call date_and_time(values=dat)
	  write(*,'(" Today is:",*(i0:,":"))')dat
	  call date_to_unix(dat,unixtime,ierr)
	  write(*,*)'Unix Epoch time is ',unixtime
	  write(*,*)'ierr is ',ierr
       end program demo_date_to_unix

  results:

       Today is:2016:7:18:-240:23:44:20:434
       Unix Epoch time is    1468899860.4340105
       ierr is		  0

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	 date_to_unix(3m_time)
days2sec(3m_time)					     days2sec(3m_time)

NAME
  days2sec(3f) - [M_time:DURATION] convert string of form [[-]dd-]hh:mm:ss.nn
  or dNNhNNmNNsNN to seconds (LICENSE:MIT)

SYNOPSIS
  elemental impure function days2sec(str) result(time)

      character(len=*),intent(in) :: str
      real(kind=realtime)	  :: time

DESCRIPTION
  Given a string representing a duration of the form [-][[[dd-]hh:]mm:]ss or
  [NNd][NNh][NNm[]NNs][NNw] return a value representing seconds.

  If "dd-" is present, units for the numbers are assumed to proceed from day
  to hour to minute to second. But if no day is present, the units are assumed
  to proceed from second to minutes to hour from left to right. That is ...

	  [-]dd-hh:mm:ss
	  [-]dd-hh:mm
	  [-]dd-hh

	  hh:mm:ss
	  mm:ss
	  ss

	  Where dd is days, hh hours, mm minutes and ss seconds.

  A decimal fraction is supported on the seconds (Actually, any of the numeric
  values may represent positive floating point numbers). Spaces are ignored.

  Simple numeric values may also be used with unit suffixes; where s,m,h, or d
  represents seconds, minutes, hours or days and w represents a week. Allowed
  aliases for w,d,h,m, and s units are

	 [NNd][NNh][NNm][NNs][NNw]

	   d   -  days,day
	   h   -  hours,hour,hr,hrs
	   m,' -  minutes,minute,min,mins
	   s," -  seconds,second,sec,secs
	   w   -  week, weeks, wk, wks

  The numeric values may represent floating point numbers.

  Spaces, commas and case are ignored.

OPTIONS
  str
    string of the general form dd-hh:mm:ss.nn or [NNd][NNh][NNm][NNs][NNw]

RETURNS
  time
    the number of seconds represented by the input string

EXAMPLE
  Sample program:

      program demo_days2sec
      use M_time, only : days2sec
      implicit none
	 write(*,*)days2sec('1-12:04:20')
	 write(*,*)'one second ',days2sec('1')
	 write(*,*)'one minute ',days2sec('1:00')
	 write(*,*)'one hour ',days2sec('1:00:00')
	 write(*,*)'one day ',days2sec('1-00:00:00')
	 write(*,*)nint(days2sec(' 1-12:04:20		   ')) == 129860
	 write(*,*)nint(days2sec(' 1.5 days		   ')) == 129600
	 write(*,*)nint(days2sec(' 1.5 days 4hrs 30minutes ')) == 145800
	 write(*,*)nint(days2sec(' 1.5d 		   ')) == 129600
	 write(*,*)nint(days2sec(' 1d2h3m4s		   ')) == 93784
	 ! duplicates
	 write(*,*)nint(days2sec(' 1d1d1d		   ')) == 259200
	 ! negative values
	 write(*,*)nint(days2sec(' 4d-12h		   ')) == 302400
      end program demo_days2sec

  Results:

      > 129860.00000000000
      > one second    1.0000000000000000
      > one minute    60.000000000000000
      > one hour    3600.0000000000000
      > one day    86400.000000000000
      > T
      > T
      > T
      > T
      > T
      > T
      > T

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	     days2sec(3m_time)
dow(3m_time)							  dow(3m_time)

NAME
  dow(3f) - [M_time:DAY_OF_WEEK] given a date-time array DAT return the day of
  the week (LICENSE:MIT)

SYNOPSIS
  subroutine dow(values, weekday, day, ierr, short)

      integer,intent(in)		    :: values(8)
      integer,intent(out),optional	    :: weekday
      character(len=*),intent(out),optional :: day
      integer,intent(out),optional	    :: ierr
      logical,intent(in),optional	    :: short

DESCRIPTION
  Given a date array DAT return the day of the week as a number and a name,
  Mon=1.

OPTIONS
  values
    "DAT" array (an integer array of the same format as the array returned by
    the intrinsic DATE_AND_TIME(3f)) describing the date to be used to
    calculate the day of the week.

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

RETURNS
  weekday
    The numeric day of the week, starting with Monday=1.  Optional.

  day
    The name of the day of the week.  Optional.

  ierr
    Error code

    •  [ 0] correct

    •  [-1] invalid input date

    •  [-2] neither day nor weekday return values were requested.

    If the error code is not returned and an error occurs, the program is
    stopped.

EXAMPLE
  Sample program:

      program demo_dow
      use M_time, only : dow
      implicit none
      integer	       :: dat(8)     ! input date array
      integer	       :: weekday
      character(len=9) :: day
      integer	       :: ierr
	call date_and_time(values=dat)
	call dow(dat, weekday, day, ierr)
	write(*,'(a,i0)')'weekday=',weekday
	write(*,'(a,a)')'day=',trim(day)
	write(*,'(a,i0)')'ierr=',ierr
      end program demo_dow

  results:

      weekday=1
      day=Monday
      ierr=0

AUTHOR
  John S. Urban, 2015-12-19

LICENSE
   MIT
			       January 26, 2025 		  dow(3m_time)
easter(3m_time) 					       easter(3m_time)

NAME
  easter(3f) - [M_time:ASTROLOGICAL] calculate date for Easter given a year
  (LICENSE:MIT)

SYNOPSIS
  subroutine easter(year,dat)

      integer, intent(in)  :: year
      integer, intent(out) :: dat

DESCRIPTION
  The Date of Easter (Sunday)

  The algorithm is due to J.-M. Oudin (1940) and is reprinted in the
  Explanatory Supplement to the Astronomical Almanac, ed. P. K. Seidelmann
  (1992). See Chapter 12, "Calendars", by L. E. Doggett.

  The following are dates of Easter from 1980 to 2024:

	 1980  April  6        1995  April 16	     2010  April  4
	 1981  April 19        1996  April  7	     2011  April 24
	 1982  April 11        1997  March 30	     2012  April  8
	 1983  April  3        1998  April 12	     2013  March 31
	 1984  April 22        1999  April  4	     2014  April 20
	 1985  April  7        2000  April 23	     2015  April  5
	 1986  March 30        2001  April 15	     2016  March 27
	 1987  April 19        2002  March 31	     2017  April 16
	 1988  April  3        2003  April 20	     2018  April  1
	 1989  March 26        2004  April 11	     2019  April 21
	 1990  April 15        2005  March 27	     2020  April 12
	 1991  March 31        2006  April 16	     2021  April  4
	 1992  April 19        2007  April  8	     2022  April 17
	 1993  April 11        2008  March 23	     2023  April  9
	 1994  April  3        2009  April 12	     2024  March 31

  N.B. The date of Easter for the Eastern Orthodox Church may be different.

OPTIONS
  year
    Year for which to calculate day that Easter falls on

RESULTS
  dat
    Date array for noon on Easter for the specified year

EXAMPLE
  Sample program:

      program demo_easter
      use M_time, only : easter, fmtdate
      implicit none
      integer :: year
      integer :: dat(8) ! year,month,day,tz,hour,minute,second,millisecond
	call date_and_time(values=dat)	! get current year
	year=dat(1)
	call easter(year, dat)
	write(*,*)fmtdate(dat,&
	"Easter day: the %d day of %L in the year of our Lord %Y")
      end program demo_easter

  Sample output:

      Easter day: the 16th day of April in the year of our Lord 2017

			       January 26, 2025 	       easter(3m_time)
fmtdate(3m_time)					      fmtdate(3m_time)

NAME
  fmtdate(3f) - [M_time:DATE_PRINTING] given DAT date-time array return date
  as string using specified format (LICENSE:MIT)

SYNOPSIS
  function fmtdate(values,format) result(timestr)

      integer,dimension(8),intent(in)	   :: values
      character(len=*),intent(in),optional :: format
      character(len=:),allocatable	   :: timestr

DESCRIPTION
  The fmtdate(3f) procedure lets you reformat a DAT array in many common
  formats using a special string containing macro names beginning with '%'. To
  see the allowable macros call or see the fmtdate_usage(3f) routine.

OPTIONS
  values
    date in a "DAT" array, which is the same format as the values returned by
    the intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

  format
    string describing how to format the "DAT" array.  For a complete
    description of the formatting macros supported see fmtdate_usage(3f).

RETURNS
  timestr
    formatted output string representing date

EXAMPLE
  Sample program:

      program demo_fmtdate
      use M_time, only : fmtdate
      implicit none
      integer :: dat(8)
	 call date_and_time(values=dat)
	 write(*,*)fmtdate(dat,"current date: %w, %l %d, %Y %H:%m:%s %N")
      end program demo_fmtdate

  results:

	The current date is Sun, Jul 17th, 2016 01:21:35 PM

AUTHOR
  John S. Urban, 2015-12-19

LICENSE
   MIT
			       January 26, 2025 	      fmtdate(3m_time)
fmtdate_usage(3m_time)					fmtdate_usage(3m_time)

NAME
  fmtdate_usage(3f) - [M_time:DATE_PRINTING] display macros recognized by
  fmtdate(3f) and now(3f) (LICENSE:MIT)

SYNOPSIS
  subroutine fmtdate_usage(indent)

      integer,intent(in),optional      :: indent

DESCRIPTION
  The fmtdate_usage(3f) subroutine displays the formatting options available
  for use in procedures such as fmtdate(3f) and now(3f).  It is typically used
  to produce up-to-date help text in commands that use the M_time(3fm) module,
  so that the formatting information only needs maintained in one place (this
  routine) and is easily displayed so users can quickly obtain a description
  of the formatting macros.

OPTIONS
  indent
    how many spaces to prefix the output with, so that calling programs can
    position the output. Default for this optional parameter is three (3).

EXAMPLE
  Sample Program:

      program demo_fmtdate_usage
      use M_time, only : fmtdate_usage
      implicit none
	 call fmtdate_usage() ! see all formatting options
      end program demo_fmtdate_usage

  results (actually call the routine to ensure this is up to date):

      Description					 Example

      Base time array:
      (1) %Y -- year, yyyy				  2016
      (2) %M -- month of year, 01 to 12 		  07
      (3) %D -- day of month, 01 to 31			  29
	  %d -- day of month, with suffix (1st, 2nd,...)  29th
      (4) %Z -- minutes from UTC			  -0240m
	  %z -- -+hh:mm from UTC			  -04:00
	  %T -- -+hhmm	from UTC			  -0400
      (5) %h -- hours, 00 to 23 			  10
	  %H -- hour (1 to 12, or twelve-hour clock)	  10
	  %N -- midnight< AM <=noon; noon<= PM <midnight  AM
      (6) %m -- minutes, 00 to 59			  54
      (7) %s -- sec, 00 to 59				  08
      (8) %x -- milliseconds 000 to 999 		  521
      Conversions:
	  %E -- Unix Epoch time 			  1469804048.5220029
	  %e -- integer value of Unix Epoch time	  1469804049
	  %F -- Modified Julian  date			  57599.121
	  %f -- integer value of Modified Julian Date	  57599
	  %G -- Baseday and Seconds			  (57599,40223.12139393)
	  %g -- integer value of Baseday and Seconds	  57599
	  %J -- Julian	date				  2457599.121
	  %j -- integer value of Julian Date(Julian Day)  2457599
	  %O -- Ordinal day (day of year)		  211
	  %o -- Whole days since Unix Epoch date	  17011
	  %U -- day of week, 1..7 Sunday=1		  6
	  %u -- day of week, 1..7 Monday=1		  5
	  %i -- ISO week of year 1..53			  30
	  %I -- iso-8601 week-numbering date(yyyy-Www-d)  2016-W30-5
       Names:
	  %l -- abbreviated month name			  Jul
	  %L -- full month name 			  July
	  %w -- first three characters of weekday	  Fri
	  %W -- weekday name				  Friday
	  %p -- phase of moon				  New
	  %P -- percent of way from new to full moon	  -1%
       Literals:
	  %% -- a literal %				  %
	  %t -- tab character
	  %b -- blank character
	  %B -- exclamation(bang) character
	  %n -- new line (system dependent)
	  %q -- single quote (apostrophe)
	  %Q -- double quote
       Duration:
	  %a -- Time since now as d-h:m:s		1-12:34:30
	  %A -- TIme since now as seconds		12810.4500
       Program timing:
	  %c -- CPU_TIME(3f) output			.21875000000000000
	  %C -- number of times this routine is used	1
	  %S -- seconds since last use of this format	.0000000000000000
	  %k -- time in seconds from SYSTEM_CLOCK(3f)	723258.812
	  %K -- time in clicks from SYSTEM_CLOCK(3f)	723258812
  Help: %? -- call fmtdate_usage

  If no percent (%) is found in the format one of several alternate
  substitutions occurs.

  If the format is composed entirely of one of the following keywords the
  following substitutions occur:

       "iso-8601",
       "iso"	       ==> %Y-%M-%DT%h:%m:%s%z
       "iso-8601W",
       "isoweek"       ==> %I 2016-W30-5
       "sql"	       ==> "%Y-%M-%D %h:%m:%s.%x"
       "sqlday"        ==> "%Y-%M-%D"
       "dash"	       ==> %Y-%M-%D
       "sqltime"       ==> "%h:%m:%s.%x"
       "rfc-2822"      ==> %w, %D %l %Y %h:%m:%s %T
       "rfc-3339"      ==> %Y-%M-%DT%h:%m:%s%z
       "date"	       ==> %w %l %D %h:%m:%s UTC%z %Y
       "short"	       ==> %w, %l %d, %Y %H:%m:%s %N UTC%z
       "long"," "      ==> %W, %L %d, %Y %H:%m:%s %N UTC%z
       "suffix"        ==> %Y%D%M%h%m%s
       "formal"        ==> The %d of %L %Y
       "lord"	       ==> the %d day of %L in the year of our Lord %Y
       "easter"        ==> FOR THE YEAR OF THE CURRENT DATE:
			Easter day: the %d day of %L in the year of our Lord %Y
       "all"	       ==> A SAMPLE OF DATE FORMATS
       "usage|help|?"  ==> %?

  Examples of single keywords

     iso-8601
     iso       : 2024-06-29T08:56:48-04:00
     iso-8601W
     isoweek   : 2024-W26-6
     sql       : "2024-06-29 08:56:48.750"
     sqlday    : "2024-06-29"
     dash      : 2024-06-29
     sqltime   : 08:56:48.833
     rfc-2822  : Sat, 29 Jun 2024 08:56:48 -0400
     rfc-3339  : 2024-06-29T08:56:48-04:00
     date      : Sat Jun 29 08:56:48 UTC-04:00 2024
     short     : Sat, Jun 29th, 2024 8:56:48 AM UTC-04:00
     long      : Saturday, June 29th, 2024 8:56:48 AM UTC-04:00
     suffix    : 20242906085648
     formal    : The 29th of June 2024
     lord      : the 29th day of June in the year of our Lord 2024
     easter    : Easter day: the 31st day of March in the year of our Lord 2024
     all       : Civil Calendar: Saturday June 29th
		 Civil Date: 2024-06-29 08:56:49 -04:00
		 Julian Date: 2460491.0394568751
		 Unix Epoch Time: 1719665809.0740056
		 Day Of Year: 181
		 ISO-8601 week: 2024-W26-6

     otherwise the following words are replaced with the most
     common macros:

     numeric values:

	year	 %Y  2016
	month	 %M  07
	day	 %D  29
	hour	 %h  10
	minute	 %m  54
	second	 %s  08
	timezone %T  0400

	epoch	 %e  1469804049
	julian	 %j  2457599
	ordinal  %O  211
	weekday  %u  5
	age	 %A  13238944.3030

     string values:

	MONTH	       %L  July
	Month|Mth      %l  Jul
	WEEKDAY        %W  Thursday
	Weekday|wkday  %w  Thu
	DAY	       %d  7th
	TIMEZONE       %z  -04:00
	Timezone       %Z  -240m
	GOOD	       %N  AM
	HOUR	       %H  10
	AGE	       %a  1200-10:30:40

     If none of these keywords are found then every letter that
     is a macro is assumed to have an implied percent in front
     of it. For example:

	YMDhms ==> %Y%M%D%h%m%s ==> 20160729105408

AUTHOR
  John S. Urban, 2015-10-24

LICENSE
   MIT
			       January 26, 2025 	fmtdate_usage(3m_time)
guessdate(3m_time)					    guessdate(3m_time)

NAME
  guessdate(3f) - [M_time:READING_DATES] reads in a date, in various formats
  (LICENSE:MIT)

SYNOPSIS
  subroutine guessdate(anot,dat)

      character(len=*),intent(in) :: anot
      integer,intent(out)	  :: dat(8)

DESCRIPTION
  Read in strings and except for looking for month names remove non-numeric
  characters and try to convert a string assumed to represent a date to a
  date-time array.

  Years should always be expressed as four-digit numbers, and except for the
  special format yyyy-mm-dd the day should come after the year. Named months
  are preferred. If ambiguous the order is assumed to be day - month - year.
  Times are assumed to be of the form HH:MM:SS

  It is planned that this routine will be superseded. As an alternative, a C
  routine exists in the standard C libraries that allows for expansive
  features when reading dates that can be called via the ISO_C_BINDING
  interface.

OPTIONS
  anot
    A string assumed to represent a date including a year, month and day.

  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

EXAMPLE
  Sample program:

      program demo_guessdate
      use M_time, only : guessdate, fmtdate
      implicit none
      character(len=20),allocatable :: datestrings(:)
      character(len=:),allocatable  :: answer
      integer			    :: dat(8)
      integer			    :: i
	 datestrings=[ &
	 & 'January 9th, 2001	',&
	 & ' Tue Jul 19 2016	',&
	 & ' 21/12/2016 	',&
	 & ' 4th of Jul 2004	' ]
	 do i=1,size(datestrings)
	    write(*,'(a)')repeat('-',80)
	    write(*,*)'TRYING ',datestrings(i)
	    call guessdate(datestrings(i),dat)
	    write(*,*)'DAT ARRAY ',dat
	    answer=fmtdate(dat)
	    write(*,*)'FOR '//datestrings(i)//' GOT '//trim(answer)
	 enddo
      end program demo_guessdate

  results:

      ---------------------------------------------------------------------
      TRYING January 9th, 2001
      DAT ARRAY 	2001  1  9   -240    0	 0   0	  0
      FOR January 9th, 2001  GOT Tuesday, January 9th, 2001 12:00:00 AM
      ---------------------------------------------------------------------
      TRYING  Tue Jul 19 2016
      DAT ARRAY 	2016  7  19  -240    0	 0   0	  0
      FOR  Tue Jul 19 2016   GOT Tuesday, July 19th, 2016 12:00:00 AM
      ---------------------------------------------------------------------
      TRYING  21/12/2016
      DAT ARRAY 	2016  12 21  -240    0	 0   0	  0
      FOR  21/12/2016	     GOT Wednesday, December 21st, 2016 12:00:00 AM
      ---------------------------------------------------------------------
      TRYING  4th of Jul 2004
      DAT ARRAY 	2004  7  4   -240    0	 0   0	  0
      FOR  4th of Jul 2004   GOT Sunday, July 4th, 2004 12:00:00 AM

LICENSE
   MIT
			       January 26, 2025 	    guessdate(3m_time)
d2m(3m_time)							  d2m(3m_time)

NAME
  d2m(3f) - [M_time:MODIFIED_JULIAN] given DAT date-time array returns
  Modified Julian Date (LICENSE:MIT)

SYNOPSIS
  function d2m(dat) result(julian)

      integer,intent(in)  :: dat(8)
      real(kind=realtime) :: modified_julian

DESCRIPTION
  Given DAT date-time array returns Modified Julian Date

OPTIONS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

  If not present, use current time.

RETURNS
  modified_juliandate
    A Modified Julian Date (MJD) measures days (and fractional days) since the
    start of 17 Nov 1858 CE in Universal Time (UTC).

EXAMPLE
  Sample program:

      program demo_d2m
      use M_time, only : d2m, realtime
      implicit none
      integer :: dat(8)
	 call date_and_time(values=dat)
	 write(*,'(" Today is:",*(i0:,":"))')dat
	 write(*,*)'Modified Julian Date is ',d2m(dat)
      end program demo_d2m

  Results:

      >  Today is:2025:1:26:-300:1:7:49:295
      >  Modified Julian Date is    60701.255431655329

AUTHOR
  John S. Urban, 2025

LICENSE
   MIT
			       January 26, 2025 		  d2m(3m_time)
d2o(3m_time)							  d2o(3m_time)

NAME
  d2o(3f) - [M_time:ORDINAL_DAY] converts DAT date-time array to Ordinal day
  (LICENSE:MIT)

SYNOPSIS
  function d2o(dat) result(ordinal)

      integer,intent(in),optional :: dat(8)
      integer			  :: ordinal

DESCRIPTION
  Given a date in the form of a "DAT" array return the Ordinal Day, (ie. "the
  day of the year").

OPTIONS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

	       dat=[ year,month,day,timezone,hour,&
		& minutes,seconds,milliseconds]

RETURNS
  ordinal
    The day of the year calculated for the given input date, where Jan 1st=1.

EXAMPLE
  Sample program:

      program demo_d2o
      use M_time, only : d2o
      implicit none
      integer :: dat(8)
	 call date_and_time(values=dat)
	 write(*,'(" Today is:",*(i0:,":"))')dat
	 write(*,*)'Day of year is:',d2o(dat)

	 ! year,month,day,timezone,hour,minute,seconds,milliseconds
	 dat=[2020,12,31,-240,12,0,0,0]
	 write(*,*)dat(1),' Days in year is:',d2o(dat)

	 dat=[2021,12,31,-240,12,0,0,0]
	 write(*,*)dat(1),' Days in year is:',d2o(dat)

	 dat=[2022,12,31,-240,12,0,0,0]
	 write(*,*)dat(1),' Days in year is:',d2o(dat)

	 dat=[2023,12,31,-240,12,0,0,0]
	 write(*,*)dat(1),' Days in year is:',d2o(dat)

	 dat=[2024,12,31,-240,12,0,0,0]
	 write(*,*)dat(1),' Days in year is:',d2o(dat)

      end program demo_d2o

  results:

      Today is:2016:7:19:-240:20:1:19:829
      Day of year is:	      201
	     2020  Days in year is:	    366
	     2021  Days in year is:	    365
	     2022  Days in year is:	    365
	     2023  Days in year is:	    365
	     2024  Days in year is:	    366

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		  d2o(3m_time)
d2u(3m_time)							  d2u(3m_time)

NAME
  d2u(3f) - [M_time:UNIX_EPOCH] given DAT date-time array returns Unix Epoch
  Time (UET starts at 0000 on 1 Jan. 1970, UTC) (LICENSE:MIT)

SYNOPSIS
  function d2u(dat) result(unixtime)

	integer,intent(in),optional :: dat(8)
	real(kind=realtime)	    :: unixtime

DESCRIPTION
  Converts a DAT date-time array to a Unix Epoch Time value. Typically
  mathematical operations such as sums, sorting and comparison are performed
  with simple UET numeric values, and then they are converted back.

OPTIONS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

  If not present the current time is used

RETURNS
  unixtime
    The "Unix Epoch" time, or the number of seconds since 00:00:00 on January
    1st, 1970, UTC.

EXAMPLE
  Sample program:

      program demo_d2u
      use M_time, only : d2u
      implicit none
      integer		:: dat(8)
	 call date_and_time(values=dat)
	 write(*,'(" Today is:",*(i0:,":"))')dat
	 write(*,*)'Unix Epoch time is ',d2u(dat)
      end program demo_d2u

  results:

      Today is:2016:7:19:-240:2:0:48:561
      Unix Epoch time is    1468908048.5610321

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 		  d2u(3m_time)
box_month(3m_time)					    box_month(3m_time)

NAME
  box_month(3f) - [M_time:DATE_PRINTING] create specified month in a character
  array (LICENSE:MIT)

SYNOPSIS
  subroutine box_month(dat,calen)

      integer,intent(in) :: dat(8)
      character(len=21)  :: calen(8)

DESCRIPTION
  box_month(3f) uses a year and month from a date array to populate a small
  character array with a calendar representing the month.

OPTIONS
  dat
    "DAT" array (an integer array of the same format as the array returned by
    the intrinsic DATE_AND_TIME(3f)) describing the date to be used to specify
    what calendar month to produce.

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

RETURNS
  calen
    returned character array holding a display of the specified month

EXAMPLE
  Sample program:

      program demo_box_month
      use M_time, only : box_month
      implicit none
      integer		:: dat(8)
      character(len=21) :: calendar(8)
	 call date_and_time(values=dat)
	 call box_month(dat,calendar)
	 write(*,'(a)')calendar
      end program demo_box_month

  results:

       >     July 2016
       >Mo Tu We Th Fr Sa Su
       >	     1	2  3
       > 4  5  6  7  8	9 10
       >11 12 13 14 15 16 17
       >18 19 20 21 22 23 24
       >25 26 27 28 29 30 31

AUTHOR
  John S. Urban, 2015

LICENSE
   MIT
			       January 26, 2025 	    box_month(3m_time)
b2d(3m_time)							  b2d(3m_time)

NAME
  b2d(3f) - [M_time:BAS] given a BAS (Baseday and Seconds) returns a date-time
  array DAT.  (LICENSE:MIT)

SYNOPSIS
  function b2d(bas) result(dat)

      type(BAStime),intent(in),optional :: bas
      integer				:: dat(8)

DESCRIPTION
  Converts a Baseday and Seconds (BAS) to a DAT date-time array.

OPTIONS
  bas
    A Baseday and seconds(MJD) is composed of whole days since the start of 17
    Nov 1858 CE in Universal Time (UTC)

    and an offset in seconds from the base day.
      If not present, use current time.

RETURNS
  dat
    Integer array holding a "DAT" array, similar in structure to the array
    returned by the intrinsic DATE_AND_TIME(3f):

		  dat=[ year,month,day,timezone,hour,&
		   & minutes,seconds,milliseconds]

EXAMPLE
  Sample program:

      program demo_b2d
      use M_time, only : b2d, d2b, fmtdate, realtime, BAStime
      !BAStime includes operator(+), operator(-)
      implicit none
      integer,parameter :: dp=kind(0.0d0)
      type(BAStime)	:: today
      type(BAStime)	:: aday
      type(BAStime)	:: newday
      integer		:: dat(8)
      character(len=*),parameter :: g='(*(g0,1x))'

	 write(*,g)'b2d:'
	 call date_and_time(values=dat) ! get the date using intrinsic
	 today=d2b(dat) 		! convert DAT to BAS
	 write(*,g)'Today=',fmtdate(b2d(today))
	 ! math is easy with Julian Days and Julian Dates

	 write(*,g)'Yesterday=',fmtdate(b2d(today+BAStime(-1,0.0_dp)))
	 write(*,g)'Tomorrow= ',fmtdate(b2d(today+BAStime(+1,0.0_dp)))

	 write(*,g)'Yesterday=',fmtdate(b2d(today+BAStime(0,-86400.0_dp)))
	 write(*,g)'Tomorrow= ',fmtdate(b2d(today+BAStime(0,+86400.0_dp)))

	 aday=BAStime(1,0.0_dp)
	 write(*,g)'Yesterday=',fmtdate(b2d(today-aday))
	 write(*,g)'Tomorrow= ',fmtdate(b2d(today+aday))

	 newday=today-aday
	 write(*,g)'Yesterday=',fmtdate(b2d(newday))
	 newday=today+aday
	 write(*,g)'Yesterday=',fmtdate(b2d(newday))
      end program demo_b2d

  Results:

   > b2d:
   > Today= Sunday, January 26th, 2025 1:13:26 AM UTC-05:00
   > Yesterday= Saturday, January 25th, 2025 1:13:26 AM UTC-05:00
   > Tomorrow=	Monday, January 27th, 2025 1:13:26 AM UTC-05:00
   > Yesterday= Saturday, January 25th, 2025 1:13:26 AM UTC-05:00
   > Tomorrow=	Monday, January 27th, 2025 1:13:26 AM UTC-05:00
   > Yesterday= Saturday, January 25th, 2025 1:13:26 AM UTC-05:00
   > Tomorrow=	Monday, January 27th, 2025 1:13:26 AM UTC-05:00
   > Yesterday= Saturday, January 25th, 2025 1:13:26 AM UTC-05:00
   > Yesterday= Monday, January 27th, 2025 1:13:26 AM UTC-05:00

AUTHOR
  John S. Urban, 2025

LICENSE
   MIT
			       January 26, 2025 		  b2d(3m_time)
